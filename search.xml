<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【树型dp】旅游规划</title>
      <link href="/2025/10/13/%E3%80%90%E6%A0%91%E5%9E%8BDP%E3%80%91%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/"/>
      <url>/2025/10/13/%E3%80%90%E6%A0%91%E5%9E%8BDP%E3%80%91%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>W市的交通规划出现了重大问题，市政府下定决心在全市各大交通路口安排疏导员来疏导密集的车流。但由于人员不足，W市市长决定只在最需要安排人员的路口安排人员。<br>具体来说，W市的交通网络十分简单，由n个交叉路口和n−1条街道构成，交叉路口路口编号依次为0,1,⋯,n−1。任意一条街道连接两个交叉路口，且任意两个交叉路口间都存在一条路径互相连接。<br>经过长期调查，结果显示，如果一个交叉路口位于W市交通网最长路径上，那么这个路口必定拥挤不堪。所谓最长路径，定义为某条路径p&#x3D;(v1,v2,v3,vk)，路径经过的路口各不相同，且城市中不存在长度大于k的路径，因此最长路径可能不唯一。因此Ｗ市市长想知道哪些路口位于城市交通网的最长路径上。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行一个整数n；<br>之后n−1行每行两个整数u,v，表示u和v的路口间存在着一条街道。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出包括若干行，每行包括一个整数——某个位于最长路径上的路口编号。为了确保解唯一，请将所有最长路径上的路口编号按编号顺序由小到大依次输出。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">0 4</span><br><span class="line">0 6</span><br><span class="line">0 7</span><br><span class="line">1 3</span><br><span class="line">2 5</span><br><span class="line">4 8</span><br><span class="line">6 9</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>对于全部数据，1≤n≤2×10^5^。</p><p>​之前有一道题也是求树上最长路径的，不过只用求最长路径的长度所以只用跑一次dfs就行了。现在还要位于最长路径上的点并且最长路径可能还不止一条，因此要跑第二次dfs了。第一次dfs跑的是求该节点的子树中最长路和次长路，第二次dfs跑的时候求的是该节点向父节点方向的最长路，转移方程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = d1[v] + <span class="number">1</span>;<span class="comment">//当前子路长度</span></span><br><span class="line"><span class="keyword">if</span> (len &gt; d1[u])&#123;<span class="comment">//比最长路长</span></span><br><span class="line">  d2[u] = d1[u];</span><br><span class="line">  d1[u] = len;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (len &gt; d2[u])&#123;<span class="comment">//比次长路长</span></span><br><span class="line"> d2[u] = len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (d1[u] == d1[v] + <span class="number">1</span>)&#123;<span class="comment">//当前子路是父节点的最长路</span></span><br><span class="line">  up[v] = <span class="built_in">max</span>(up[u], d2[u]) + <span class="number">1</span>;<span class="comment">//取父节点的次长路作为子节点的父路</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  up[v] = <span class="built_in">max</span>(up[u], d1[u]) + <span class="number">1</span>;<span class="comment">//否则取父节点的最长路作为子节点的父路</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; </span><br><span class="line">vector &lt;<span class="type">int</span>&gt; adj[maxn];</span><br><span class="line"><span class="type">int</span> d1[maxn], d2[maxn], up[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  d1[u] = <span class="number">0</span>;</span><br><span class="line">  d2[u] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">    <span class="type">int</span> len = d1[v] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; d1[u])&#123;</span><br><span class="line">      d2[u] = d1[u];</span><br><span class="line">      d1[u] = len;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (len &gt; d2[u])&#123;</span><br><span class="line">      d2[u] = len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (d1[u] == d1[v] + <span class="number">1</span>)&#123;</span><br><span class="line">      up[v] = <span class="built_in">max</span>(up[u], d2[u]) + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      up[v] = <span class="built_in">max</span>(up[u], d1[u]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs2</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> max_road = <span class="number">0</span>;</span><br><span class="line">  vector &lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="type">int</span> temp = d1[i] + <span class="built_in">max</span>(d2[i], up[i]);</span><br><span class="line">    <span class="keyword">if</span> (temp &gt; max_road)&#123;</span><br><span class="line">      max_road = temp;</span><br><span class="line">      ans.<span class="built_in">clear</span>();</span><br><span class="line">      ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp == max_road)&#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x : ans)&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树型dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【分层图】Magical Girl Haze</title>
      <link href="/2025/10/12/%E5%88%86%E5%B1%82%E5%9B%BE/"/>
      <url>/2025/10/12/%E5%88%86%E5%B1%82%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><strong>题目描述</strong><br>某个国家有 N 座城市，以及 M 条从 u 到 v 的有向道路（1 ≤ u, v ≤ N）。每条道路都有一个距离 ci。<br>Haze 是一位魔法少女，住在城市 1，她可以选择不超过 K 条道路，将它们的距离变为 0。现在她想去城市 N，请你帮她计算从城市 1 到城市 N 的最小距离。</p><p><strong>输入</strong><br>第一行有一个整数 T（1 ≤ T ≤ 5），表示测试用例的数量。<br>对于每个测试用例：</p><ul><li>第一行有三个整数 N, M, K。</li><li>接下来的 M 行，每行有三个整数，描述一条道路：Ui, Vi, Ci。<br>u 和 v 之间可能存在多条道路。</li></ul><p>数据保证：</p><ul><li>N ≤ 100000</li><li>M ≤ 200000</li><li>K ≤ 10</li><li>0 ≤ c[i] ≤ 1e9</li><li>城市 1 和城市 N 之间至少存在一条路径。</li></ul><p><strong>输出</strong><br>对于每个测试用例，输出最小距离。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 6 1</span><br><span class="line">1 2 2</span><br><span class="line">1 3 4</span><br><span class="line">2 4 3</span><br><span class="line">3 4 1</span><br><span class="line">3 5 6</span><br><span class="line">4 5 2</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>​分层图的模板题，无需多言，上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dian</span>&#123;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  ll c;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> dian &amp;a, <span class="type">const</span> dian &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.c &gt; b.c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector &lt;dian&gt; adj[maxn];</span><br><span class="line">priority_queue &lt;dian, vector&lt;dian&gt;, cmp&gt; qe;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    adj[i].<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    ll c;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    adj[a].<span class="built_in">push_back</span>(&#123;b, c, <span class="number">0</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  qe.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">  vector &lt;vector&lt;ll&gt;&gt; <span class="built_in">dis</span>(n + <span class="number">1</span>, vector &lt;ll&gt; (k + <span class="number">1</span>, <span class="number">1e18</span>));</span><br><span class="line">  <span class="keyword">while</span>(!qe.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    dian temp = qe.<span class="built_in">top</span>();</span><br><span class="line">    qe.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (temp.c &gt; dis[temp.b][temp.k]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : adj[temp.b])&#123;</span><br><span class="line">      <span class="keyword">if</span> (temp.k == k)&#123;<span class="comment">//已经用了k次魔法，不能再用了</span></span><br><span class="line">        <span class="keyword">if</span> (temp.c + e.c &lt; dis[e.b][temp.k])&#123;</span><br><span class="line">          dis[e.b][temp.k] = temp.c + e.c;</span><br><span class="line">          qe.<span class="built_in">push</span>(&#123;e.b, temp.c + e.c, temp.k&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.k &lt; k)&#123;<span class="comment">//没到k次，就要分用魔法和不用魔法两种情况讨论</span></span><br><span class="line">        <span class="keyword">if</span> (temp.c + e.c &lt; dis[e.b][temp.k])&#123;</span><br><span class="line">          dis[e.b][temp.k] = temp.c + e.c;</span><br><span class="line">          qe.<span class="built_in">push</span>(&#123;e.b, temp.c + e.c, temp.k&#125;);        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.c &lt; dis[e.b][temp.k + <span class="number">1</span>])&#123;</span><br><span class="line">          dis[e.b][temp.k + <span class="number">1</span>] = temp.c;</span><br><span class="line">          qe.<span class="built_in">push</span>(&#123;e.b, temp.c, temp.k + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; dis[n][k] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【二分图】Magic Potion</title>
      <link href="/2025/10/12/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
      <url>/2025/10/12/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p><strong>题目描述</strong><br>在一个岛屿上住着 n 位英雄和 m 只怪物。这些天怪物变得非常凶残，因此英雄们决定消灭岛上的怪物。然而，第 i 位英雄只能杀死属于集合 Mi 中的一只怪物。<br>策略师 Joe 拥有 k 瓶魔法药水，每瓶药水可以增强一位英雄的能力，让他能够多杀死一只怪物。由于药水非常强大，每位英雄最多只能服用一瓶药水。<br>请帮助 Joe 找出，如果他采用最优策略，英雄们最多能杀死多少只怪物。</p><p><strong>输入</strong><br>第一行包含三个整数 n, m, k（1 ≤ n, m, k ≤ 500）—— 分别表示英雄的数量、怪物的数量和药水的瓶数。<br>接下来的 n 行中，每行首先包含一个整数 ti，表示集合 Mi 的大小，随后是 ti 个整数 Mi,j（1 ≤ j ≤ ti），表示第 i 位英雄能够杀死的怪物的索引（1 起始索引）（1 ≤ ti ≤ m，1 ≤ Mi,j ≤ m）。</p><p><strong>输出</strong><br>输出英雄们能够杀死的怪物的最大数量。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 5 2</span><br><span class="line">4 1 2 3 5</span><br><span class="line">2 2 5</span><br><span class="line">2 1 2</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>​一眼看出是二分图匹配，用匈牙利算法跑了半天没跑出正确答案，原因就在于这个魔法药水。后来发现用网络流做更加简单：首先确立源点1，然后是普通杀怪点2，(1, 2)的容量是n，表示n个英雄各自可以杀一只怪；接着建立嗑药杀怪点3，(1, 3)的容量是k，表示还有至多k个英雄能各自再杀一只怪。最终将2、3与各个英雄相连，英雄与各自能杀的怪相连，所有怪与汇点相连，并将这三步中所有边的容量设置为1，建图就大功告成了。这样跑一遍ISAP，答案就出来了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>, head[N];</span><br><span class="line"><span class="type">int</span> n, m, k, maxflow;</span><br><span class="line"><span class="type">int</span> dep[N], gap[N], cur[N];</span><br><span class="line"><span class="type">int</span> s,t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="type">int</span> v, next, val;</span><br><span class="line">&#125;node[<span class="number">10</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  node[++cnt].v = v;</span><br><span class="line">  node[cnt].val = val;</span><br><span class="line">  node[cnt].next = head[u];</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = s; i &lt;= t; i++)&#123;</span><br><span class="line">    dep[i] = <span class="number">-1</span>;</span><br><span class="line">    gap[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dep[t] = <span class="number">0</span>;</span><br><span class="line">  gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  queue &lt;<span class="type">int</span>&gt; qe;</span><br><span class="line">  qe.<span class="built_in">push</span>(t);</span><br><span class="line">  <span class="keyword">while</span>(!qe.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u = qe.<span class="built_in">front</span>();</span><br><span class="line">    qe.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = node[i].next)&#123;</span><br><span class="line">      <span class="type">int</span> v = node[i].v;</span><br><span class="line">      <span class="keyword">if</span> (dep[v] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">      qe.<span class="built_in">push</span>(v);</span><br><span class="line">      dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">      gap[dep[v]]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> flow)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (u == t)&#123;</span><br><span class="line">    maxflow += flow;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> used = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> &amp;i = cur[u]; i; i = node[i].next)&#123;</span><br><span class="line">    <span class="type">int</span> v = node[i].v;</span><br><span class="line">    <span class="keyword">if</span> (node[i].val &amp;&amp; dep[v] + <span class="number">1</span> == dep[u])&#123;</span><br><span class="line">      <span class="type">int</span> mi = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(flow - used, node[i].val));</span><br><span class="line">      <span class="keyword">if</span> (mi)&#123;</span><br><span class="line">        node[i].val -= mi;</span><br><span class="line">        node[i ^ <span class="number">1</span>].val += mi;</span><br><span class="line">        used += mi;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (used == flow) <span class="keyword">return</span> used;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  gap[dep[u]]--;</span><br><span class="line">  <span class="keyword">if</span> (gap[dep[u]] == <span class="number">0</span>) dep[s] = t + <span class="number">1</span>;</span><br><span class="line">  dep[u]++;</span><br><span class="line">  gap[dep[u]]++;</span><br><span class="line">  <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ISAP</span><span class="params">()</span></span>&#123;</span><br><span class="line">  maxflow = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="keyword">while</span>(dep[s] &lt; t + <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s; i &lt;= t + <span class="number">1</span>; i++) cur[i] = head[i];</span><br><span class="line">    <span class="built_in">dfs</span>(s, inf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">  <span class="built_in">addedge</span>(<span class="number">1</span>, <span class="number">2</span>, n);</span><br><span class="line">  <span class="built_in">addedge</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">addedge</span>(<span class="number">1</span>, <span class="number">3</span>, k);</span><br><span class="line">  <span class="built_in">addedge</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  s = <span class="number">1</span>, t = <span class="number">4</span> + n + m;</span><br><span class="line">  <span class="type">int</span> hero_start = <span class="number">4</span>, hero_end = <span class="number">3</span> + n, mon_end = <span class="number">3</span> + m + n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = hero_start; i &lt;= hero_end; i++)&#123;</span><br><span class="line">    <span class="built_in">addedge</span>(<span class="number">2</span>, i, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">addedge</span>(i, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">addedge</span>(<span class="number">3</span>, i, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">addedge</span>(i, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    <span class="keyword">while</span>(num--)&#123;</span><br><span class="line">      <span class="type">int</span> x;</span><br><span class="line">      cin &gt;&gt; x;</span><br><span class="line">      <span class="built_in">addedge</span>(i, hero_end + x, <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">addedge</span>(hero_end + x, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = hero_end + <span class="number">1</span>; i &lt;= mon_end; i++)&#123;</span><br><span class="line">    <span class="built_in">addedge</span>(i, t, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">addedge</span>(t, i, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">ISAP</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 二分图 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树型dp】数字转换</title>
      <link href="/2025/10/12/study-dp-i/"/>
      <url>/2025/10/12/study-dp-i/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>如果一个数x的约数和y（不包括他本身）比他本身小，那么x可以变成y，y也可以变成x。例如4可以变为3，1可以变为7。限定所有数字变换在不超过n的正整数范围内进行，求不断进行数字变换且不出现重复数字的最多变换步数。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入一个正整数n。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出不断进行数字变换且不出现重复数字的最多变换步数。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>一种方案为 4→3→1→7<br>对于100%的数据，1≤n≤50000。</p><p>​这一题初看怎么也想不到会是dp，不过在看到n的数字给的比较小后就能想到建图。建图后可以发现得到了一个森林，一开始想跑两遍dfs找最长路径，但后来看了题解发现用树型dp可以只用跑一次dfs。</p><p>​让我们令du[]表示从该节点出发的最长路，dv[]表示次长路，那么转移方程是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">  <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="built_in">dfs</span>(v, u);</span><br><span class="line">  <span class="keyword">if</span> (du[v] &gt; du[u] - <span class="number">1</span>)&#123;<span class="comment">//比最长路要大</span></span><br><span class="line">    dv[u] = du[u] - <span class="number">1</span>;<span class="comment">//原最长路变次长路</span></span><br><span class="line">    du[u] = du[v] + <span class="number">1</span>;<span class="comment">//新的最长路为du[v]加上(u, v)这一条边</span></span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (du[v] &gt; dv[u])&#123;<span class="comment">//比次长路要大</span></span><br><span class="line">    dv[u] = du[v];<span class="comment">//更新次长路</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​下面是完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; adj[<span class="number">50010</span>];</span><br><span class="line"><span class="type">int</span> du[<span class="number">50010</span>], dv[<span class="number">50010</span>], ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">50010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> j = x / i;</span><br><span class="line">        <span class="keyword">if</span> (i != j) sum += i + j;</span><br><span class="line">        <span class="keyword">else</span> sum += i;  </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= <span class="number">1</span> &amp;&amp; sum &lt;= n &amp;&amp; sum &lt; x)&#123;</span><br><span class="line">      adj[x].<span class="built_in">push_back</span>(sum);</span><br><span class="line">      adj[sum].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  vis[u] = <span class="number">1</span>;</span><br><span class="line">  du[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    <span class="keyword">if</span> (du[v] &gt; du[u] - <span class="number">1</span>)&#123;</span><br><span class="line">      dv[u] = du[u] - <span class="number">1</span>;</span><br><span class="line">      du[u] = du[v] + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (du[v] &gt; dv[u])&#123;</span><br><span class="line">      dv[u] = du[v];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = <span class="built_in">max</span>(ans, du[u] + dv[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios:: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="built_in">pre</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) <span class="built_in">dfs</span>(i, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans - <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树型dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【区间dp】凸多边形的划分</title>
      <link href="/2025/10/11/study-dp-c/"/>
      <url>/2025/10/11/study-dp-c/</url>
      
        <content type="html"><![CDATA[<p><strong>题目描述</strong><br>给定一个具有N个顶点的凸多边形，将顶点从1至N标号，每个顶点的权值都是一个正整数。将这个凸多边形划分成N−2个互不相交的三角形，试求这些三角形顶点的权值乘积和至少为多少。<br><strong>输入</strong><br>输入第一行为顶点数N（N≤50）<br>第二行依次为顶点1至顶点N的权值。<br><strong>输出</strong><br>输出仅一行，为这些三角形顶点的权值乘积和的最小值。<br><strong>样例输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">121 122 123 245 231</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12214884</span><br></pre></td></tr></table></figure><p>​这道题目看似几何问题，实际上居然是一道区间dp。大体思路不难：先选取两个顶点i，j连成一条边，然后在区间[i，j]内找到第三点k作为分割点，转移方程为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k][j] + (i128)w[i] * w[k] * w[j]);</span><br></pre></td></tr></table></figure><p>显而易见在初始化时相邻的两个点连成的边应该初始化为0，其余边初始化为inf。</p><p>还有一点要注意，TK给的数据数值特别大，要开int128或者高精度！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span> &lt;&lt; (ostream &amp;os, i128 n)&#123;</span><br><span class="line">  string s;</span><br><span class="line">  <span class="keyword">while</span>(n)&#123;</span><br><span class="line">    s += <span class="string">&#x27;0&#x27;</span> + n % <span class="number">10</span>;</span><br><span class="line">    n /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> i128 inf = <span class="number">1e30</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll w[<span class="number">110</span>];</span><br><span class="line">i128 dp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios:: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; w[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (j - i &lt; <span class="number">2</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> dp[i][j] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">3</span>; len &lt;= n; len++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)&#123;</span><br><span class="line">      <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)&#123;</span><br><span class="line">        dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k][j] + (i128)w[i] * w[k] * w[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
