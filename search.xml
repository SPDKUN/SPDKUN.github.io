<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2025/12/03/STL/"/>
      <url>/2025/12/03/STL/</url>
      
        <content type="html"><![CDATA[<p>​​C++ STL（<strong>标准模板库</strong>，Standard Template Library）是C++标准库的核心组成部分，提供了一系列<strong>通用、高效、模板化的容器、算法和迭代器</strong>，实现了<strong>数据结构和算法的分离</strong>。</p><p>目录：</p><ul><li>vector</li><li>set</li><li>map</li><li>stack</li><li>queue</li><li>deque</li><li>priority_queue</li></ul><p><strong>1、vector(约等于数组)</strong></p><p>头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><p>定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"><span class="comment">//定义大小</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">//直接放入元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//复制</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; brr = arr;</span><br><span class="line"><span class="comment">//二维vector</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">arr</span>(<span class="number">100</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>常用函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sort</span></span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//arr.begin(), arr.end()均为迭代器</span></span><br><span class="line"><span class="comment">//vector的插入</span></span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 删除末尾元素 - O(1)</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>&#125;;</span><br><span class="line">arr.<span class="built_in">pop_back</span>();  <span class="comment">// vec: [10, 20, 30, 40, 50, 60]</span></span><br><span class="line"><span class="comment">// 删除指定位置 - O(n)</span></span><br><span class="line">arr.<span class="built_in">erase</span>(arr.<span class="built_in">begin</span>() + <span class="number">2</span>);  <span class="comment">// 删除第3个元素: 30, vec: [10, 20, 40, 50, 60]</span></span><br><span class="line"><span class="comment">// 删除范围</span></span><br><span class="line">arr.<span class="built_in">erase</span>(arr.<span class="built_in">begin</span>() + <span class="number">1</span>, arr.<span class="built_in">begin</span>() + <span class="number">3</span>);  <span class="comment">// 删除[20, 40)</span></span><br><span class="line"><span class="comment">//清空vector</span></span><br><span class="line">arr.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">//获得vector的大小</span></span><br><span class="line">arr.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//判断vector是否为空(返回布尔值)</span></span><br><span class="line">arr.<span class="built_in">empty</span>();</span><br><span class="line"><span class="comment">//访问最后一个元素</span></span><br><span class="line">arr.<span class="built_in">back</span>();</span><br><span class="line"><span class="comment">//重设大小</span></span><br><span class="line">arr.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><strong>2、set(元素唯一且自动排序，涉及排序时间复杂度为O(log n))</strong></p><p>头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br></pre></td></tr></table></figure><p>定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set &lt;<span class="type">int</span>&gt; se;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; se = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;<span class="comment">//&#123;1, 2, 3, 5&#125;</span></span><br></pre></td></tr></table></figure><p>自定义排序规则</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//降序</span></span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; se = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;<span class="comment">//&#123;5, 3, 2, 1&#125;</span></span><br><span class="line"><span class="comment">//自定义排序</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">​<span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">​<span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="type">const</span> node &amp;a,<span class="type">const</span> node &amp;b)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">​​<span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">​&#125;</span><br><span class="line">&#125;</span><br><span class="line">set&lt;node, cmp&gt; se;</span><br></pre></td></tr></table></figure><p>常用函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入函数</span></span><br><span class="line">se.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//查找元素(找到返回迭代器, 没找到返回se.end())</span></span><br><span class="line"><span class="keyword">auto</span> it = se.<span class="built_in">find</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">auto</span> lower = se.<span class="built_in">lower_bound</span>(<span class="number">25</span>);  <span class="comment">// 第一个&gt;=25的元素</span></span><br><span class="line"><span class="keyword">auto</span> upper = se.<span class="built_in">upper_bound</span>(<span class="number">35</span>);  <span class="comment">// 第一个&gt;35的元素</span></span><br><span class="line"><span class="comment">//按值删除</span></span><br><span class="line">se.<span class="built_in">erase</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//按迭代器删除</span></span><br><span class="line"><span class="keyword">auto</span> it = se.<span class="built_in">find</span>(<span class="number">10</span>);</span><br><span class="line">se.<span class="built_in">erase</span>(it);</span><br><span class="line"><span class="comment">// 删除范围</span></span><br><span class="line">se.<span class="built_in">erase</span>(se.<span class="built_in">find</span>(<span class="number">50</span>), se.<span class="built_in">end</span>());  <span class="comment">// 删除50及之后的元素</span></span><br><span class="line"><span class="comment">//获得大小</span></span><br><span class="line">se.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 清空所有</span></span><br><span class="line">se.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">//访问首尾元素</span></span><br><span class="line">*se.<span class="built_in">begin</span>();</span><br><span class="line">*se.<span class="built_in">rbegin</span>();</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : se) cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = se.<span class="built_in">begin</span>(); it != se.<span class="built_in">end</span>(); it++) cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>例题</p><h1 id="P1059-NOIP-2006-普及组-明明的随机数"><a href="#P1059-NOIP-2006-普及组-明明的随机数" class="headerlink" title="P1059[NOIP 2006 普及组] 明明的随机数"></a>P1059[NOIP 2006 普及组] 明明的随机数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 $N$ 个 $1$ 到 $1000$ 之间的随机整数 $(N\leq100)$，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入有两行，第 $1$ 行为 $1$ 个正整数，表示所生成的随机数的个数 $N$。</p><p>第 $2$ 行有 $N$ 个用空格隔开的正整数，为所产生的随机数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出也是两行，第 $1$ 行为 $1$ 个正整数 $M$，表示不相同的随机数的个数。</p><p>第 $2$ 行为 $M$ 个用空格隔开的正整数，为从小到大排好序的不相同的随机数。</p><h2 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例 #1"></a>输入输出样例 #1</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入 #1"></a>输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">20 40 32 67 40 20 89 300 400 15</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出 #1"></a>输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">15 20 32 40 67 89 300 400</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h2><p>NOIP 2006 普及组 第一题</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  set &lt;<span class="type">int</span>&gt; se;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    se.<span class="built_in">insert</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; se.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x : se) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他set</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_set<span class="comment">//无序, 元素唯一</span></span><br><span class="line">multiset<span class="comment">//有序, 元素可重复</span></span><br></pre></td></tr></table></figure><p><strong>3、map(存储键值对，默认按键升序排列)</strong></p><p>头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br></pre></td></tr></table></figure><p>定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key, value&gt; mp;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; mp;<span class="comment">//名字作键, 学号做值</span></span><br></pre></td></tr></table></figure><p>常用函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">mp[<span class="string">&quot;Alice&quot;</span>] = <span class="number">10</span>;</span><br><span class="line">mp.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">10</span>&#125;);</span><br><span class="line"><span class="comment">//修改值</span></span><br><span class="line">mp[<span class="string">&quot;Alice&quot;</span>] = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//删除值</span></span><br><span class="line">mp.<span class="built_in">erase</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">  it-&gt;first;<span class="comment">//key</span></span><br><span class="line">  it-&gt;second;<span class="comment">//value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [key, value] : mp);</span><br></pre></td></tr></table></figure><p>例题</p><h1 id="P3879-TJOI2010-阅读理解"><a href="#P3879-TJOI2010-阅读理解" class="headerlink" title="P3879 [TJOI2010] 阅读理解"></a>P3879 [TJOI2010] 阅读理解</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>英语老师留了 $N$ 篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为整数 $N$ ，表示短文篇数，其中每篇短文只含空格和小写字母。</p><p>按下来的 $N$ 行，每行描述一篇短文。每行的开头是一个整数 $L$ ，表示这篇短文由 $L$ 个单词组成。接下来是 $L$ 个单词，单词之间用一个空格分隔。</p><p>然后为一个整数 $M$ ，表示要做几次询问。后面有 $M$ 行，每行表示一个要统计的生词。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个生词输出一行，统计其在哪几篇短文中出现过，并按从小到大输出短文的序号，序号不应有重复，序号之间用一个空格隔开（注意第一个序号的前面和最后一个序号的后面不应有空格）。如果该单词一直没出现过，则输出一个空行。</p><h2 id="输入输出样例-1-1"><a href="#输入输出样例-1-1" class="headerlink" title="输入输出样例 #1"></a>输入输出样例 #1</h2><h3 id="输入-1-1"><a href="#输入-1-1" class="headerlink" title="输入 #1"></a>输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">9 you are a good boy ha ha o yeah</span><br><span class="line">13 o my god you like bleach naruto one piece and so do i</span><br><span class="line">11 but i do not think you will get all the points</span><br><span class="line">5</span><br><span class="line">you</span><br><span class="line">i</span><br><span class="line">o</span><br><span class="line">all</span><br><span class="line">naruto</span><br></pre></td></tr></table></figure><h3 id="输出-1-1"><a href="#输出-1-1" class="headerlink" title="输出 #1"></a>输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">2 3</span><br><span class="line">1 2</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="说明-提示-1"><a href="#说明-提示-1" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h2><p>对于 $30%$ 的数据， $1\le M\le 10^3$ 。</p><p>对于 $100%$ 的数据，$1\le M\le 10^4$，$1\le N\le 10^3$ 。</p><p>每篇短文长度（含相邻单词之间的空格）$\le 5\times 10^3$ 字符，每个单词长度 $\le 20$ 字符。</p><p>感谢@钟梓俊添加的一组数据。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  map &lt;string, set&lt;<span class="type">int</span>&gt;&gt; mp;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    cin &gt;&gt; l;</span><br><span class="line">    <span class="keyword">while</span>(l--)&#123;</span><br><span class="line">      string s;</span><br><span class="line">      cin &gt;&gt; s;</span><br><span class="line">      mp[s].<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> m;</span><br><span class="line">  cin &gt;&gt; m;</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : mp[s])&#123;</span><br><span class="line">      cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他map</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map<span class="comment">//无序，快速查找、不需要顺序</span></span><br><span class="line">multimap<span class="comment">//一键多值、有序</span></span><br></pre></td></tr></table></figure><p><strong>4、stack(栈，先进后出)</strong></p><p>头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure><p>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义栈</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line">st.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//访问栈顶</span></span><br><span class="line">st.<span class="built_in">top</span>();</span><br><span class="line"><span class="comment">//访问stack的大小</span></span><br><span class="line">st.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//判断stack是否为空(返回布尔值)</span></span><br><span class="line">stack.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure><p>![[Pasted image 20251203220755.png]]</p><p>例题：</p><h1 id="B2165-括号匹配"><a href="#B2165-括号匹配" class="headerlink" title="B2165 括号匹配"></a>B2165 括号匹配</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定只由 $6$ 种括号字符组成的字符串：<code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>&#123;</code>, <code>&#125;</code>。判断每个字符串是否为“合法括号序列”，合法则输出 YES，否则输出 NO。合法括号序列的定义：</p><ul><li>空串合法；</li><li>若 A 合法，则 <code>(A)</code>, <code>[A]</code>, <code>&#123;A&#125;</code> 均合法；</li><li>若 A 与 B 均合法，则 AB 合法。</li></ul><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $T$，表示数据组数。接下来 $T$ 行，每行一个只包含上述 $6$ 种字符的字符串。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个字符串，输出一行：</p><ul><li>若其为合法括号序列，输出 YES；</li><li>否则输出 NO。</li></ul><h2 id="输入输出样例-1-2"><a href="#输入输出样例-1-2" class="headerlink" title="输入输出样例 #1"></a>输入输出样例 #1</h2><h3 id="输入-1-2"><a href="#输入-1-2" class="headerlink" title="输入 #1"></a>输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">()[]&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-1-2"><a href="#输出-1-2" class="headerlink" title="输出 #1"></a>输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="输入输出样例-2"><a href="#输入输出样例-2" class="headerlink" title="输入输出样例 #2"></a>输入输出样例 #2</h2><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入 #2"></a>输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">()</span><br><span class="line">([)]</span><br><span class="line">([])&#123;&#125;</span><br><span class="line">((((</span><br><span class="line">&#123;[()()]&#125;</span><br><span class="line">&#125;&#123;</span><br></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出 #2"></a>输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="说明-提示-2"><a href="#说明-提示-2" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h2><p>记单串长度记为 $|S|$。测试数据满足 $1 \leq |S| \leq 10^6$，$1 \leq T \leq 2\times 10^5$，同一输入文件内总长度 $\sum |S| \leq 2\times 10^6$，字符串只包含字符 <code>()[]&#123;&#125;</code>。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    stack &lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> x : s)&#123;</span><br><span class="line">      <span class="keyword">if</span> (x == <span class="string">&#x27;(&#x27;</span> || x == <span class="string">&#x27;[&#x27;</span> || x == <span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(x);</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">          ans = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="string">&#x27;)&#x27;</span> &amp;&amp; st.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">          ans = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="string">&#x27;]&#x27;</span> &amp;&amp; st.<span class="built_in">top</span>() != <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">          ans = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; st.<span class="built_in">top</span>() != <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">          ans = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;          </span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) ans = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、queue(队列，先进先出)</strong></p><p>头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure><p>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义队列</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; qe;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line">qe.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line">qe.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//访问队首</span></span><br><span class="line">qe.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">//访问队尾</span></span><br><span class="line">qe.<span class="built_in">back</span>();</span><br><span class="line"><span class="comment">//访问队列的大小</span></span><br><span class="line">qe.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//判断队列是否为空(返回布尔值)</span></span><br><span class="line">qe.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure><p>例题</p><h1 id="B3625-迷宫寻路"><a href="#B3625-迷宫寻路" class="headerlink" title="B3625 迷宫寻路"></a>B3625 迷宫寻路</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>机器猫被困在一个矩形迷宫里。</p><p>迷宫可以视为一个 $n\times m$ 矩阵，每个位置要么是空地，要么是墙。机器猫只能从一个空地走到其上、下、左、右的空地。</p><p>机器猫初始时位于 $(1, 1)$ 的位置，问能否走到 $(n, m)$ 位置。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，两个正整数 $n,m$。  </p><p>接下来 $n$ 行，输入这个迷宫。每行输入一个长为 $m$ 的字符串，<code>#</code> 表示墙，<code>.</code> 表示空地。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>仅一行，一个字符串。如果机器猫能走到 $(n, m)$，则输出 <code>Yes</code>；否则输出 <code>No</code>。</p><h2 id="输入输出样例-1-3"><a href="#输入输出样例-1-3" class="headerlink" title="输入输出样例 #1"></a>输入输出样例 #1</h2><h3 id="输入-1-3"><a href="#输入-1-3" class="headerlink" title="输入 #1"></a>输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">.##.#</span><br><span class="line">.#...</span><br><span class="line">...#.</span><br></pre></td></tr></table></figure><h3 id="输出-1-3"><a href="#输出-1-3" class="headerlink" title="输出 #1"></a>输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="说明-提示-3"><a href="#说明-提示-3" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h2><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>路线如下：$(1,1)\to (2,1) \to (3,1) \to (3,2)\to (3,3) \to (2, 3) \to (2, 4) \to (2, 5) \to (3, 5)$</p><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 $100%$ 的数据，保证 $1 \leq n, m \leq 100$，且 $(1,1)$ 和 $(n, m)$ 均为空地。</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> maze[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">      cin &gt;&gt; maze[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  queue &lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; qe;</span><br><span class="line">  qe.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">  vis[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="type">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span>(!qe.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y] = qe.<span class="built_in">front</span>();</span><br><span class="line">    qe.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (x == n &amp;&amp; y == m)&#123;</span><br><span class="line">      ans = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">      <span class="type">int</span> new_x = x + dx[i];</span><br><span class="line">      <span class="type">int</span> new_y = y + dy[i];</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">1</span> &lt;= new_x &amp;&amp; new_x &lt;= n &amp;&amp; <span class="number">1</span> &lt;= new_y &amp;&amp; new_y &lt;= m </span><br><span class="line">      ​​&amp;&amp; !vis[new_x][new_y] &amp;&amp; maze[new_x][new_y] != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        vis[new_x][new_y] = <span class="number">1</span>;</span><br><span class="line">        qe.<span class="built_in">push</span>(&#123;new_x, new_y&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ans) cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125; ​</span><br></pre></td></tr></table></figure><p><strong>6、deque(双端队列，两头都可以进出的队列)</strong></p><p>头文件<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义deque</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line">dq.<span class="built_in">push_front</span>();</span><br><span class="line">dq.<span class="built_in">push_back</span>();</span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">dq.<span class="built_in">pop_front</span>();</span><br><span class="line">dq.<span class="built_in">pop_back</span>();</span><br><span class="line">dq.<span class="built_in">erase</span>(dq.<span class="built_in">begin</span>() + k)<span class="comment">//删除第k-1个元素</span></span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line">dq[<span class="number">0</span>];<span class="comment">//可以像数组一样用下标访问</span></span><br></pre></td></tr></table></figure><p>例题</p><h1 id="P1540-NOIP-2010-提高组-机器翻译"><a href="#P1540-NOIP-2010-提高组-机器翻译" class="headerlink" title="P1540 [NOIP 2010 提高组] 机器翻译"></a>P1540 [NOIP 2010 提高组] 机器翻译</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2010 提高组 T1</p><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。</p><p>这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。</p><p>假设内存中有 $M$ 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 $M-1$，软件会将新单词存入一个未使用的内存单元；若内存中已存入 $M$ 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。</p><p>假设一篇英语文章的长度为 $N$ 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>共 $2$ 行。每行中两个数之间用一个空格隔开。</p><p>第一行为两个正整数 $M,N$，代表内存容量和文章的长度。</p><p>第二行为 $N$ 个非负整数，按照文章的顺序，每个数（大小不超过 $1000$）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，为软件需要查词典的次数。</p><h2 id="输入输出样例-1-4"><a href="#输入输出样例-1-4" class="headerlink" title="输入输出样例 #1"></a>输入输出样例 #1</h2><h3 id="输入-1-4"><a href="#输入-1-4" class="headerlink" title="输入 #1"></a>输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 7</span><br><span class="line">1 2 1 5 4 4 1</span><br></pre></td></tr></table></figure><h3 id="输出-1-4"><a href="#输出-1-4" class="headerlink" title="输出 #1"></a>输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="说明-提示-4"><a href="#说明-提示-4" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h2><h3 id="样例解释-1"><a href="#样例解释-1" class="headerlink" title="样例解释"></a>样例解释</h3><p>整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：</p><ol><li><code>1</code>：查找单词 1 并调入内存。</li><li><code>1 2</code>：查找单词 2 并调入内存。</li><li><code>1 2</code>：在内存中找到单词 1。</li><li><code>1 2 5</code>：查找单词 5 并调入内存。</li><li><code>2 5 4</code>：查找单词 4 并调入内存替代单词 1。</li><li><code>2 5 4</code>：在内存中找到单词 4。</li><li><code>5 4 1</code>：查找单词 1 并调入内存替代单词 2。</li></ol><p>共计查了 $5$ 次词典。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul><li>对于 $10%$ 的数据有 $M&#x3D;1$，$N \leq 5$；</li><li>对于 $100%$ 的数据有 $1 \leq M \leq 100$，$1 \leq N \leq 1000$。</li></ul><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> m, n;</span><br><span class="line">  cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">  <span class="type">bool</span> vis[<span class="number">1010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    dq.<span class="built_in">push_back</span>(x);</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    ans++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dq.<span class="built_in">size</span>() &gt; m)&#123;</span><br><span class="line">      vis[dq.<span class="built_in">front</span>()] = <span class="number">0</span>;</span><br><span class="line">      dq.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7、priority_queue(优先队列，基于堆实现，自动排序，总是返回优先级最高的元素)</strong></p><p>头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure><p>定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq;<span class="comment">//默认大顶堆，最大元素在堆顶</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp&gt; pq;<span class="comment">//自定义排序</span></span><br></pre></td></tr></table></figure><p>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入元素</span></span><br><span class="line">pq.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//删除堆顶元素</span></span><br><span class="line">pq.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//访问堆顶元素</span></span><br><span class="line">pq.<span class="built_in">top</span>();</span><br><span class="line"><span class="comment">//判断优先队列的大小</span></span><br><span class="line">pq.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//判断是否为空(返回布尔值)</span></span><br><span class="line">pq.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure><p>例题</p><h1 id="P1090-NOIP-2004-提高组-合并果子"><a href="#P1090-NOIP-2004-提高组-合并果子" class="headerlink" title="P1090 [NOIP 2004 提高组] 合并果子"></a>P1090 [NOIP 2004 提高组] 合并果子</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p><a href="https://www.luogu.com.cn/problem/P6033">P6033</a> 为本题加强版。</p><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。</p><p>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</p><p>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。</p><p>例如有 $3$ 种果子，数目依次为 $1$，$2$，$9$。可以先将 $1$、$2$ 堆合并，新堆数目为 $3$，耗费体力为 $3$ 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$，耗费体力为 $12$。所以多多总共耗费体力 $&#x3D;3+12&#x3D;15$。可以证明 $15$ 为最小的体力耗费值。</p><h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><p>共两行。  </p><p>第一行是一个整数 $n(1\leq n\leq 10^4)$，表示果子的种类数。  </p><p>第二行包含 $n$ 个整数，用空格分隔，第 $i$ 个整数 $a_i(1\leq a_i\leq 2\times 10^4)$ 是第 $i$ 种果子的数目。</p><h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 $2^{31}$。</p><h2 id="输入输出样例-1-5"><a href="#输入输出样例-1-5" class="headerlink" title="输入输出样例 #1"></a>输入输出样例 #1</h2><h3 id="输入-1-5"><a href="#输入-1-5" class="headerlink" title="输入 #1"></a>输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 </span><br><span class="line">1 2 9</span><br></pre></td></tr></table></figure><h3 id="输出-1-5"><a href="#输出-1-5" class="headerlink" title="输出 #1"></a>输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h2 id="说明-提示-5"><a href="#说明-提示-5" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h2><p>对于 $30%$ 的数据，保证有 $n \le 10^3$；</p><p>对于 $50%$ 的数据，保证有 $n \le 5\times10^3$；</p><p>对于全部的数据，保证有 $n \le 10^4$。</p><p> 代码<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    pq.<span class="built_in">push</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(pq.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">int</span> a = pq.<span class="built_in">top</span>();</span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> b = pq.<span class="built_in">top</span>();</span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">    ans += a + b;</span><br><span class="line">    pq.<span class="built_in">push</span>(a + b);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】斜率优化dp</title>
      <link href="/2025/11/18/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp/"/>
      <url>/2025/11/18/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp/</url>
      
        <content type="html"><![CDATA[<p>​当推出类似下面的转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = <span class="built_in">min</span>(dp[j] + A[i] * B[j]), j &lt; i</span><br></pre></td></tr></table></figure><p>​用两层for循环会tle：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">​dp[i] = inf;</span><br><span class="line">​<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">​​dp[i] = <span class="built_in">min</span>(dp[i], dp[j] + A[i] * B[j]);</span><br><span class="line">​&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​此时将原式看成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[j] - (-A[i]) * B[j]</span><br><span class="line"></span><br><span class="line">dp[j] = (-A[i]) * B[j] + dp[i]</span><br><span class="line">​  y   = ​    k   *  x   +   b</span><br></pre></td></tr></table></figure><p>​相当于用斜率为-A[i] 的直线在一堆点集(B[j], dp[j])中截的一个截距最小的，相当于用该直线去逼近一个下凸包。（若是求最大值就是逼近上凸包）<br>​如何维护下凸包？将点按x从小到大排序，从第一个点开始向第二个点连线，然后将斜率入栈。下图包的连线斜率应该是逐渐递增的，如果当前第i点和第i+1点的连线斜率比栈顶斜率小，那么弹出栈顶斜率并删除第i-1点和第i点的连线，连接第i-1点和第i+1点重新进行比较。<br>​如何用直线逼近下凸包？由于下凸包的连线斜率随x增大而增大，所以可以用二分。<br>​下面是例题：</p><h1 id="P3195-HNOI2008-玩具装箱"><a href="#P3195-HNOI2008-玩具装箱" class="headerlink" title="P3195 [HNOI2008] 玩具装箱"></a>P3195 [HNOI2008] 玩具装箱</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>P 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。</p><p>P 教授有编号为 $1 \cdots n$ 的 $n$ 件玩具，第 $i$ 件玩具经过压缩后的一维长度为 $C_i$。</p><p>为了方便整理，P 教授要求：</p><ul><li><p>在一个一维容器中的玩具编号是连续的。</p></li><li><p>同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果将第 $i$ 件玩具到第 $j$ 个玩具放到一个容器中，那么容器的长度将为 $x&#x3D;j-i+\sum\limits_{k&#x3D;i}^{j}C_k$。</p></li></ul><p>制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 $x$，其制作费用为 $(x-L)^2$。其中 $L$ 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 $L$。但他希望所有容器的总费用最小。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有两个整数，用一个空格隔开，分别代表 $n$ 和 $L$。</p><p>第 $2$ 到 第 $(n + 1)$ 行，每行一个整数，第 $(i + 1)$ 行的整数代表第 $i$ 件玩具的长度 $C_i$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数，代表所有容器的总费用最小是多少。</p><h2 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例 #1"></a>输入输出样例 #1</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入 #1"></a>输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出 #1"></a>输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h2><p>对于全部的测试点，$1 \leq n \leq 5 \times 10^4$，$1 \leq L \leq 10^7$，$1 \leq C_i \leq 10^7$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">令he表示C的前缀和</span><br><span class="line">可得转移方程:</span><br><span class="line">dp[i] = <span class="built_in">min</span>(dp[j] + (i - (j + <span class="number">1</span>) + he[i] - he[j] - L) ^ <span class="number">2</span>, j &lt; i</span><br><span class="line">令A[i] = he[i] + i, B[j] = A[j] + L + <span class="number">1</span></span><br><span class="line">dp[i] = <span class="built_in">min</span>(dp[j] + (A[i] - B[j]) ^ <span class="number">2</span>), j &lt; i</span><br><span class="line">dp[i] = dp[j] + A[i] ^ <span class="number">2</span> - <span class="number">2</span> * A[i]*B[j] + B[j] ^ <span class="number">2</span>;</span><br><span class="line">整理，得:</span><br><span class="line">dp[i] - A[i] ^ <span class="number">2</span> = dp[j] + B[j] ^ <span class="number">2</span> + (<span class="number">-2</span> * A[i]) * B[j]</span><br><span class="line">dp[j] + B[j] ^ <span class="number">2</span> = (<span class="number">2</span> * A[i]) * B[j] + (dp[i] - A[i] ^ <span class="number">2</span>)</span><br><span class="line">y = dp[j] + B[j] ^ <span class="number">2</span></span><br><span class="line">k = <span class="number">2</span> * A[i]</span><br><span class="line">x = B[j]</span><br><span class="line">b = dp[i] - A[i] ^ <span class="number">2</span></span><br></pre></td></tr></table></figure><p>​完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line">ll n, L;</span><br><span class="line">ll he[maxn], A[maxn], B[maxn], dp[maxn];</span><br><span class="line">ll y[maxn];<span class="comment">//y = dp[j] + B[j] ^ 2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; L;</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    ll x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    he[i] = he[i - <span class="number">1</span>] + x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    A[i] = he[i] + i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    B[i] = A[i] + L + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  y[<span class="number">0</span>] = dp[<span class="number">0</span>] + B[<span class="number">0</span>] * B[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">//维护凸包</span></span><br><span class="line">  vector &lt;<span class="type">int</span>&gt; <span class="built_in">q</span>(n + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//凸包大小</span></span><br><span class="line">  <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//初始点为0</span></span><br><span class="line">  q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">      <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">​​  <span class="comment">//分子和分母</span></span><br><span class="line">      ll fz = y[q[mid + <span class="number">1</span>]] - y[q[mid]];</span><br><span class="line">      ll fm = B[q[mid + <span class="number">1</span>]] - B[q[mid]];</span><br><span class="line">      <span class="comment">//找到斜率最相近的</span></span><br><span class="line">      <span class="keyword">if</span> (fz &gt;= <span class="number">2</span> * A[i] * fm)&#123;</span><br><span class="line">        r = mid;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = q[l];</span><br><span class="line">    dp[i] = dp[j] + (A[i] - B[j]) * (A[i] - B[j]);</span><br><span class="line">    y[i] = dp[i] + B[i] * B[i];</span><br><span class="line">    <span class="comment">//维护凸包</span></span><br><span class="line">    <span class="keyword">while</span>(size &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">      <span class="comment">//头两个节点</span></span><br><span class="line">      <span class="type">int</span> j1 = q[size - <span class="number">2</span>];</span><br><span class="line">      <span class="type">int</span> j2 = q[size - <span class="number">1</span>];</span><br><span class="line">      <span class="comment">//栈顶斜率</span></span><br><span class="line">      ll fz1 = y[j2] - y[j1];</span><br><span class="line">      ll fm1 = B[j2] - B[j1];</span><br><span class="line">      <span class="comment">//新斜率</span></span><br><span class="line">      ll fz2 = y[i] - y[j2];</span><br><span class="line">      ll fm2 = B[i] - B[j2];</span><br><span class="line">      <span class="comment">//栈顶斜率比新斜率还大，弹出</span></span><br><span class="line">      <span class="keyword">if</span> (fz1 * fm2 &gt;= fz2 * fm1) size--;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压入新元素</span></span><br><span class="line">    q[size++] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; dp[n] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​当然，我们发现斜率具有单调性，可以使用单调队列优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">deque &lt;<span class="type">int</span>&gt; qe;</span><br><span class="line">  qe.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">  ​<span class="comment">//移除不可能成为最优决策的点</span></span><br><span class="line">    <span class="keyword">while</span>(qe.<span class="built_in">size</span>() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">      <span class="type">int</span> j1 = qe[<span class="number">0</span>];</span><br><span class="line">      <span class="type">int</span> j2 = qe[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 检查斜率 (j1,j2) 是否 &lt;= 2*A[i]</span></span><br><span class="line">      <span class="keyword">if</span> (y[j2] - y[j1] &lt;= <span class="number">2</span> * A[i] * (B[j2] - B[j1]))&#123;</span><br><span class="line">        qe.<span class="built_in">pop_front</span>();<span class="comment">// 移除 j1，因为 j2 更优且后面查询只会更大</span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队首即为最优决策点</span></span><br><span class="line">    <span class="type">int</span> j = qe.<span class="built_in">front</span>();</span><br><span class="line">    dp[i] = dp[j] + (A[i] - B[j]) * (A[i] - B[j]);</span><br><span class="line">    y[i] = dp[i] + B[i] * B[i];</span><br><span class="line">    <span class="comment">//队尾维护：确保新点加入后仍为下凸壳</span></span><br><span class="line">    <span class="keyword">while</span>(qe.<span class="built_in">size</span>() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">      <span class="type">int</span> j1 = qe[qe.<span class="built_in">size</span>() - <span class="number">2</span>];</span><br><span class="line">      <span class="type">int</span> j2 = qe[qe.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">      </span><br><span class="line">      ll fz1 = y[j2] - y[j1];</span><br><span class="line">      ll fm1 = B[j2] - B[j1];</span><br><span class="line">      ll fz2 = y[i] - y[j2];</span><br><span class="line">      ll fm2 = B[i] - B[j2];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fz1 * fm2 &gt;= fz2 * fm1)&#123;</span><br><span class="line">        qe.<span class="built_in">pop_back</span>();</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    qe.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/11/17/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE/"/>
      <url>/2025/11/17/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>邻接矩阵</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 65535</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Vertex;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> WeightType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">GNode</span> *PtrToGNode;</span><br><span class="line"><span class="comment">//定义图</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> Nv;<span class="comment">//顶点数量</span></span><br><span class="line">  <span class="type">int</span> Ne;<span class="comment">//边的数量</span></span><br><span class="line">  WeightType G[MaxVertexNum][MaxVertexNum];<span class="comment">//边的权重</span></span><br><span class="line">  DataType Data[MaxVertexNum];<span class="comment">//顶点数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode MGraph;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ENode</span> *PtrToENode;</span><br><span class="line"><span class="comment">//定义边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ENode</span>&#123;</span><br><span class="line">  <span class="comment">//点1和点2</span></span><br><span class="line">  Vertex V1, V2;</span><br><span class="line">  <span class="comment">//边的权重</span></span><br><span class="line">  WeightType Weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToENode Edge;</span><br><span class="line"><span class="comment">//初始化图</span></span><br><span class="line"><span class="function">MGraph <span class="title">CreateGraph</span><span class="params">(<span class="type">int</span> VertexNum)</span></span>&#123;</span><br><span class="line">  Vertex V, W;</span><br><span class="line">  MGraph Graph;</span><br><span class="line">  <span class="comment">//创建图</span></span><br><span class="line">  Graph = (MGraph)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> GNode));</span><br><span class="line">  <span class="comment">//顶点数</span></span><br><span class="line">  Graph-&gt;Nv = VertexNum;</span><br><span class="line">  Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//初始化权重为inf</span></span><br><span class="line">  <span class="keyword">for</span> (V = <span class="number">0</span>; V &lt; Graph-&gt;Nv; V++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (W = <span class="number">0</span>; W &lt; Graph-&gt;Nv; W++)&#123;</span><br><span class="line">      Graph-&gt;G[V][W] = INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertEdge</span><span class="params">(MGraph Graph, Edge E)</span></span>&#123;</span><br><span class="line">  Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;</span><br><span class="line">  <span class="comment">//若是无向图还要插入反向边</span></span><br><span class="line">  <span class="comment">//Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function">MGraph <span class="title">BuildGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">  MGraph Graph;</span><br><span class="line">  Edge E;</span><br><span class="line">  Vertex V;</span><br><span class="line">  <span class="type">int</span> Nv, i;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Nv);</span><br><span class="line">  Graph = <span class="built_in">CreateGraph</span>(Nv);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(Graph-&gt;Ne));</span><br><span class="line">  <span class="keyword">if</span>(Graph-&gt;Ne != <span class="number">0</span>)&#123;</span><br><span class="line">    E = (Edge)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ENode));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Graph-&gt;Ne; i++)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);</span><br><span class="line">      <span class="built_in">InsertEdge</span>(Graph, E);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (V = <span class="number">0</span>; V &lt; Graph-&gt;Nv; V++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;(Graph-&gt;Data[V]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邻接表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 65535</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Vertex;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> WeightType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ENode</span> * PtrToENode;</span><br><span class="line"><span class="comment">//定义边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ENode</span>&#123;</span><br><span class="line">  Vertex V1, V2;</span><br><span class="line">  WeightType Weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToENode Edge;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AdjVNode</span> * PtrToAdjVNode;</span><br><span class="line"><span class="comment">//定义邻接点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AdjVNode</span>&#123;</span><br><span class="line">  <span class="comment">//邻接点号</span></span><br><span class="line">  Vertex AdjV;</span><br><span class="line">  <span class="comment">//邻接边的权重</span></span><br><span class="line">  WeightType Weight;</span><br><span class="line">  <span class="comment">//邻接点的下一个指针</span></span><br><span class="line">  PtrToAdjVNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义点的邻接链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Vnode</span>&#123;</span><br><span class="line">  <span class="comment">//头指针</span></span><br><span class="line">  PtrToAdjVNode FirstEdge;</span><br><span class="line">  DataType Data;</span><br><span class="line">&#125;AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">GNode</span> * PtrToGNode;</span><br><span class="line"><span class="comment">//定义图</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> Nv;</span><br><span class="line">  <span class="type">int</span> Ne;</span><br><span class="line">  <span class="comment">//邻接表</span></span><br><span class="line">  AdjList G;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode LGraph;</span><br><span class="line"><span class="comment">//初始化图</span></span><br><span class="line"><span class="function">LGraph <span class="title">CreateGraph</span><span class="params">(<span class="type">int</span> VertexNum)</span></span>&#123;</span><br><span class="line">  Vertex V;</span><br><span class="line">  LGraph Graph;</span><br><span class="line"></span><br><span class="line">  Graph = (LGraph)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> GNode));</span><br><span class="line">  Graph-&gt;Nv = VertexNum;</span><br><span class="line">  Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//初始化头节点</span></span><br><span class="line">  <span class="keyword">for</span> (V = <span class="number">0</span>; V &lt; Graph-&gt;Nv; V++)&#123;</span><br><span class="line">    Graph-&gt;G[V].FirstEdge = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertEdge</span><span class="params">(LGraph Graph, Edge E)</span></span>&#123;</span><br><span class="line">  <span class="comment">//创立新插入的邻接点</span></span><br><span class="line">  PtrToAdjVNode NewNode;</span><br><span class="line">  NewNode = (PtrToAdjVNode)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> AdjVNode));</span><br><span class="line">  NewNode-&gt;AdjV = E-&gt;V2;</span><br><span class="line">  NewNode-&gt;Weight = E-&gt;Weight;</span><br><span class="line">  <span class="comment">//在头节点处插入并更新头节点</span></span><br><span class="line">  NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;</span><br><span class="line">  Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;</span><br><span class="line">  <span class="comment">//以下为无向图反向边插入</span></span><br><span class="line">  NewNode = (PtrToAdjVNode)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> AdjVNode));</span><br><span class="line">  NewNode-&gt;AdjV = E-&gt;V1;</span><br><span class="line">  NewNode-&gt;Weight = E-&gt;Weight;</span><br><span class="line">  NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;</span><br><span class="line">  Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function">LGraph <span class="title">BuildGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">  LGraph Graph;</span><br><span class="line">  Edge E;</span><br><span class="line">  Vertex V;</span><br><span class="line">  <span class="type">int</span> Nv, i;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Nv);</span><br><span class="line">  Graph = <span class="built_in">CreateGraph</span>(Nv);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(Graph-&gt;Ne));</span><br><span class="line">  <span class="keyword">if</span> (Graph-&gt;Ne != <span class="number">0</span>)&#123;</span><br><span class="line">    E = (Edge)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ENode));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Graph-&gt;Ne; i++)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);</span><br><span class="line">      <span class="built_in">InsertEdge</span>(Graph, E);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (V = <span class="number">0</span>; V &lt; Graph-&gt;Nv; V++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;(Graph-&gt;G[V].Data));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【模板】dp合集</title>
      <link href="/2025/11/10/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91dp%E5%90%88%E9%9B%86/"/>
      <url>/2025/11/10/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91dp%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><strong>1、万能背包</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"><span class="type">int</span> v[<span class="number">11010</span>],w[<span class="number">11010</span>];<span class="comment">//体积和价值，为二进制拆分要开大点</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">2010</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n,V;<span class="comment">//总类量和总容量</span></span><br><span class="line">  cin &gt;&gt; n &gt;&gt; V;</span><br><span class="line">  <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> vv,ww,ss;<span class="comment">//体积、价值、数量</span></span><br><span class="line">    cin &gt;&gt; vv &gt;&gt; ww &gt;&gt; ss;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k&lt;=ss)&#123;<span class="comment">//二进制拆分</span></span><br><span class="line">      cnt++;</span><br><span class="line">      v[cnt]=k*vv;</span><br><span class="line">      w[cnt]=k*ww;</span><br><span class="line">      ss-=k;</span><br><span class="line">      k*=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ss&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      v[cnt]=ss*vv;</span><br><span class="line">      w[cnt]=ss*ww;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=V;j&gt;=v[i];j--)&#123;</span><br><span class="line">      dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; dp[V];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、数位dp</strong><br>用于统计符合条件的数字个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">20</span>][<span class="number">15</span>], arr[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="comment">//初始化dp数组，-1代表还没结果</span></span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> pre, <span class="type">bool</span> limit, <span class="type">bool</span> lead)</span></span>&#123;<span class="comment">//当前数位、前一个数字、是否受限、是否前导</span></span><br><span class="line">  <span class="keyword">if</span> (pos == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//代表所有数位已经找完</span></span><br><span class="line">  <span class="keyword">if</span> (!limit &amp;&amp; !lead &amp;&amp; dp[pos][pre] != <span class="number">-1</span>) <span class="keyword">return</span> dp[pos][pre];<span class="comment">//记忆化</span></span><br><span class="line">  <span class="type">int</span> up = limit ? arr[pos] : <span class="number">9</span>;<span class="comment">//若当前受限只能取对应位数字作上限</span></span><br><span class="line">  <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lead &amp;&amp; i &lt; pre) <span class="keyword">continue</span>;<span class="comment">//这里处理条件，本题是计算不递减数字个数</span></span><br><span class="line">    temp += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, i, limit &amp;&amp; (i == up), lead &amp;&amp; (i == <span class="number">0</span>));<span class="comment">//统计个数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!limit &amp;&amp; !lead) dp[pos][pre] = temp;<span class="comment">//记忆化</span></span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x)&#123;<span class="comment">//存储每位数字</span></span><br><span class="line">    arr[pos++] = x % <span class="number">10</span>;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dfs</span>(pos - <span class="number">1</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">init</span>();<span class="comment">//记得初始化</span></span><br><span class="line">  <span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">get_num</span>(b) - <span class="built_in">get_num</span>(a - <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若题目不是统计数字而是求平方和（题目[【数位dp】恨7不成妻]）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  ll cnt, sum, sum2;<span class="comment">////分别表示符合条件的个数、总和、平方和</span></span><br><span class="line">&#125;;</span><br><span class="line">  node temp = node&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">7</span>) <span class="keyword">continue</span>;</span><br><span class="line">    node j = <span class="built_in">dfs</span>(pos - <span class="number">1</span>, (sum + i ) % <span class="number">7</span>, (num * <span class="number">10</span> + i) % <span class="number">7</span>, limited &amp;&amp; i == up);</span><br><span class="line">    ll B = i * pw[pos];</span><br><span class="line">    temp.cnt = (temp.cnt + j.cnt) % mod;</span><br><span class="line">    temp.sum = (temp.sum + j.cnt * B + j.sum) % mod;</span><br><span class="line">    temp.sum2 = (temp.sum2 + j.cnt * B % mod * B % mod + j.sum2 + <span class="number">2</span> * j.sum % mod * B % mod) % mod;    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>3、树型dp</strong><br>在后序遍历的位置进行状态转移。<br>以下为一种状态转移的优化版本：<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  sz[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    sz[u] += sz[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">min</span>(n, sz[u]); i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">min</span>(sz[v], j - <span class="number">1</span>); j++)&#123;</span><br><span class="line">        dp[u][i] = <span class="built_in">max</span>(dp[u][i], dp[u][i - j - <span class="number">1</span>] + dp[v][j] + w[u]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> <strong>4、状压dp</strong><br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左移和右移</span></span><br><span class="line">mask &lt;&lt; <span class="number">1</span>;</span><br><span class="line">mask &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">//两个mask在相同位置上同时存在1,既相同位置只能存在一个但冲突</span></span><br><span class="line">(mask1 &amp; mask2) != <span class="number">0</span>;</span><br><span class="line"><span class="comment">//将mask的第k位从0变为1（k从0开始）</span></span><br><span class="line">mask = mask | (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line"><span class="comment">//将mask的第k位从1变为0（k从0开始）</span></span><br><span class="line">mask = mask &amp; ~(<span class="number">1</span> &lt;&lt; k);</span><br><span class="line"><span class="comment">//将mask的第k位取反（k从0开始）</span></span><br><span class="line">mask = mask ^ (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line"><span class="comment">//mask全部取反</span></span><br><span class="line">mask = ~mask;</span><br><span class="line"><span class="comment">//出现当前位置mask2为0但mask为1的情况</span></span><br><span class="line">(mask1 &amp; (~mask2)) != <span class="number">0</span></span><br></pre></td></tr></table></figure><br> <strong>5、区间dp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)&#123;</span><br><span class="line">    <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)&#123;</span><br><span class="line">      <span class="comment">//这里写状态转移</span></span><br><span class="line">      dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、单调队列优化</strong><br>当dp出现了从i之前的一段区间内的最值转移到i，可以用单调队列优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">deque &lt;<span class="type">int</span>&gt; dq;<span class="comment">//dq存下标</span></span><br><span class="line">dq.<span class="built_in">push_back</span>(<span class="number">0</span>);<span class="comment">//设置虚拟起始点0，保证队列不为空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">  <span class="comment">//维护滑动窗口长度，这里当前状态i将从[i - k, i - 1]转移而来</span></span><br><span class="line">  <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt; i - k)&#123;</span><br><span class="line">    dq.<span class="built_in">pop_front</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//状态转移</span></span><br><span class="line">  <span class="comment">//······</span></span><br><span class="line">  <span class="comment">//维护单调性，不同题维护方式不同</span></span><br><span class="line">  <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; arr[dq.<span class="built_in">back</span>()] &gt; arr[i])&#123;</span><br><span class="line">    dq.<span class="built_in">pop_back</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将当前元素添加进队列中，供后续元素使用</span></span><br><span class="line">  dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">  <span class="comment">/*注意每次循环都是使用之前的元素，所以先状态转移再添加当前元素*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【单调队列】旅行问题</title>
      <link href="/2025/11/06/%E3%80%90%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E3%80%91%E6%97%85%E8%A1%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2025/11/06/%E3%80%90%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E3%80%91%E6%97%85%E8%A1%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>John打算驾驶一辆汽车周游一个环形公路。公路上总共有 车站，每站都有若干升汽油（有的站可能油量为零），每升油可以让汽车行驶一千米。John必须从某个车站出发，一直按顺时针（或逆时针）方向走遍所有的车站，并回到起点。在一开始的时候，汽车内油量为零，John每到一个车站就把该站所有的油都带上（起点站亦是如此），行驶过程中不能出现没有油的情况。<br>判断以每个车站为起点能否按条件成功周游一周。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行是一个整数n（3≤n≤1000000），表示环形公路上的车站数。<br>接下来n行，每行两个整数。第i+1行含有：pi（0≤pi≤2000000000），表示第i号车站的存油量；di(0&lt;di≤2000000000，表示第i号车站到下一站的距离。  </p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出共n行，如果从第i号车站出发，一直按顺时针（或逆时针）方向行驶，能够成功周游一圈，则在第i行输出TAK，否则输出NIE。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 1</span><br><span class="line">1 2</span><br><span class="line">5 2</span><br><span class="line">0 1</span><br><span class="line">5 4</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TAK</span><br><span class="line">NIE</span><br><span class="line">TAK</span><br><span class="line">NIE</span><br><span class="line">TAK</span><br></pre></td></tr></table></figure><p>​对于每个站点，p[i] - d[i]表示经过该站点后车可以开多远，构造它的前缀和数组he[]。从起点x出发环形一周，对于经过的每一个站点y，都应该满足he[y] - he[x] &gt;&#x3D; 0。<br>​题目就变为维护一个长度为n的滑动窗口，每次找出其中最小的he[]，只要最小的满足he[] - he[start] &gt;&#x3D; 0，那么其他的也满足。<br>​题目提示可以顺逆时针，因此要正着扫一次再倒着扫一次：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">p</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">d</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; p[i] &gt;&gt; d[i];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">s</span><span class="params">(<span class="number">2</span> * n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;<span class="comment">//环形开2n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> idx = (i - <span class="number">1</span>) % n + <span class="number">1</span>;<span class="comment">//环形</span></span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + p[idx] - d[idx];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    deque&lt;pair&lt;ll, <span class="type">int</span>&gt;&gt; dq;<span class="comment">//&lt;前缀和，序号&gt;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">back</span>().first &gt; s[i]) &#123;</span><br><span class="line">            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.<span class="built_in">push_back</span>(&#123;s[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> start = i - n;<span class="comment">//起点</span></span><br><span class="line">        <span class="keyword">if</span> (dq.<span class="built_in">front</span>().first - s[start - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ans[start] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//维护窗口</span></span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>().second &lt;= i - n) &#123;</span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//维护单调性</span></span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">back</span>().first &gt; s[i]) &#123;</span><br><span class="line">            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.<span class="built_in">push_back</span>(&#123;s[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    dq.<span class="built_in">clear</span>();</span><br><span class="line">    s.<span class="built_in">assign</span>(<span class="number">2</span> * n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//倒着来一次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">2</span> * n; i &lt;= <span class="number">2</span> * n; i++, j--) &#123;</span><br><span class="line">        <span class="type">int</span> idx = (j - <span class="number">1</span>) % n + <span class="number">1</span>;<span class="comment">//当前点</span></span><br><span class="line">        <span class="type">int</span> prev_idx = (j - <span class="number">1</span> &gt; <span class="number">0</span> ? j - <span class="number">1</span> : n) - <span class="number">1</span>;<span class="comment">//上一个点</span></span><br><span class="line">        prev_idx = (prev_idx % n + n) % n + <span class="number">1</span>;</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + p[idx] - d[prev_idx];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">back</span>().first &gt; s[i]) &#123;</span><br><span class="line">            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.<span class="built_in">push_back</span>(&#123;s[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">2</span> * n - i + <span class="number">1</span>;<span class="comment">//起点</span></span><br><span class="line">        <span class="keyword">if</span> (dq.<span class="built_in">front</span>().first - s[i - n - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ans[start] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>().second &lt;= i - n) &#123;</span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">back</span>().first &gt; s[i]) &#123;</span><br><span class="line">            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.<span class="built_in">push_back</span>(&#123;s[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; (ans[i] ? <span class="string">&quot;TAK&quot;</span> : <span class="string">&quot;NIE&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>J. January&#39;s Color</title>
      <link href="/2025/11/04/%E3%80%90%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E%E3%80%91The%202025%20ICPC%20Asia%20Xi&#39;an%20Regional%20Contest%20J.%20January&#39;s%20Color/"/>
      <url>/2025/11/04/%E3%80%90%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E%E3%80%91The%202025%20ICPC%20Asia%20Xi&#39;an%20Regional%20Contest%20J.%20January&#39;s%20Color/</url>
      
        <content type="html"><![CDATA[<p>![[statement_14690.pdf]]</p><p>​题目大意是，有一颗根为1的带权树，这颗树不存在只有一个儿子的父节点。现在有两种获得节点的方式，一是消耗权值获得一个节点，二是失去两个已有的兄弟节点获得它们的父节点。现在给出多次询问，每次询问会先送你一个节点并且告诉你目标节点。在最终只拥有目标节点的情况下，判断能否通过送的节点得到目标节点，如果能，求出最小权值费用。<br>​1、对于每个节点，获得它的费用是它自己的权值或则它儿子中最小的两个费用之和，可以用树上dp来计算。<br>​2、要判断送的节点x能否得到目标节点y，那y一定是x的祖先。通过dfs的出入栈顺序可以判断：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_pre</span><span class="params">(<span class="type">int</span> son, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> in[fa] &lt;= in[son] &amp;&amp; out[son] &lt;= out[fa];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​3、快速计算费用，用到树上倍增。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">up[maxn][<span class="number">20</span>];<span class="comment">//up[i][j]表示节点i的(1 &lt;&lt; j)祖先;</span></span><br><span class="line">sum[maxn][<span class="number">20</span>];<span class="comment">//sum[i][j]表示节点i得到祖先(1 &lt;&lt; j)的费用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如何理解树上倍增的转移方程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">20</span>; j++)</span><br><span class="line">​  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">​up[i][j] = up[up[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">​sum[i][j] = sum[i][j - <span class="number">1</span>] + sum[up[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line"><span class="comment">//将i到up[i][j]视为一条长度为(1 &lt;&lt; j)的直线，i到up[i][j - 1]长度为(1 &lt;&lt; (j - 1)), up[i][j - 1]到up[i][j]长度也为(1 &lt;&lt; (j - 1))，两段加起来就可以得到up[i][j]。</span></span><br></pre></td></tr></table></figure><p>​完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; adj[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pre[maxn], dep[maxn];</span><br><span class="line"><span class="comment">//记录当前节点的父节点，记录当前节点深度</span></span><br><span class="line">ll arr[maxn], cost[maxn], min_son[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//节点权值，获得节点最小费用，节点儿子中最小的两个费用</span></span><br><span class="line"><span class="type">int</span> up[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="comment">//倍增祖先数组</span></span><br><span class="line">ll sum[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="comment">//倍增前缀和数组</span></span><br><span class="line"><span class="type">int</span> in[maxn], out[maxn], timer = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//时间戳</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  dep[u] = d;<span class="comment">//记录深度</span></span><br><span class="line"></span><br><span class="line">  pre[u] = fa;<span class="comment">//记录父节点</span></span><br><span class="line"></span><br><span class="line">  in[u] = ++timer;<span class="comment">//记录dfs入栈时间</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  ll min1 = <span class="number">1e10</span>, min2 = <span class="number">1e10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(v, u, d + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cost[v] &lt; min1)&#123;</span><br><span class="line"></span><br><span class="line">      min2 = min1;</span><br><span class="line"></span><br><span class="line">      min1 = cost[v];</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cost[v] &lt; min2)&#123;</span><br><span class="line"></span><br><span class="line">      min2 = cost[v];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  min_son[u][<span class="number">0</span>] = min1, min_son[u][<span class="number">1</span>] = min2;</span><br><span class="line"></span><br><span class="line">  cost[u] = <span class="built_in">min</span>(arr[u], min1 + min2);</span><br><span class="line"></span><br><span class="line">  out[u] = timer;<span class="comment">//记录dfs出栈时间</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">//判断y是否是x祖先</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_pre</span><span class="params">(<span class="type">int</span> son, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> in[fa] &lt;= in[son] &amp;&amp; out[son] &lt;= out[fa];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; arr[i];</span><br><span class="line"></span><br><span class="line">    adj[i].<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line"></span><br><span class="line">    adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line"></span><br><span class="line">    adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  timer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">​​  <span class="comment">//初始化倍增数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"></span><br><span class="line">    up[i][<span class="number">0</span>] = pre[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pre[i] != <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cost[i] == min_son[pre[i]][<span class="number">0</span>])&#123;</span><br><span class="line">​​<span class="comment">//父节点儿子最小费用是i，则i到其父节点的费用为min2</span></span><br><span class="line">        sum[i][<span class="number">0</span>] = min_son[pre[i]][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ​<span class="comment">//否则所需费用为min1</span></span><br><span class="line">        sum[i][<span class="number">0</span>] = min_son[pre[i]][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">      sum[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">​  <span class="comment">//开始构造倍增数组，注意循环内外层，级数在外，节点在内</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">20</span>; j++)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">​​  <span class="comment">//还有父节点</span></span><br><span class="line">      <span class="keyword">if</span> (up[i][j - <span class="number">1</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">​​<span class="comment">//更新新一级的父节点</span></span><br><span class="line">        up[i][j] = up[up[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">​​<span class="comment">//更新新一级的费用</span></span><br><span class="line">        sum[i][j] = sum[i][j - <span class="number">1</span>] + sum[up[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">​​<span class="comment">//没有父节点了</span></span><br><span class="line">        up[i][j] = <span class="number">0</span>;</span><br><span class="line">​​<span class="comment">//费用保持不变</span></span><br><span class="line">        sum[i][j] = sum[i][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">is_pre</span>(x, y))&#123;</span><br><span class="line"></span><br><span class="line">      cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">​<span class="comment">//x和y相等时费用为0</span></span><br><span class="line">    <span class="keyword">if</span> (x == y)&#123;</span><br><span class="line"></span><br><span class="line">      cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">​<span class="comment">//计算深度差</span></span><br><span class="line">    <span class="type">int</span> diff = dep[x] - dep[y];</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cur = x;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">​<span class="comment">//向上倍增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">20</span> - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (diff &gt;= (<span class="number">1</span> &lt;&lt; j))&#123;</span><br><span class="line">​​</span><br><span class="line">        ans += sum[cur][j];</span><br><span class="line">​​<span class="comment">//当前节点移至其祖先节点</span></span><br><span class="line">        cur = up[cur][j];</span><br><span class="line"></span><br><span class="line">        diff -= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(t--)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】单调队列优化dp</title>
      <link href="/2025/10/31/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96dp/"/>
      <url>/2025/10/31/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96dp/</url>
      
        <content type="html"><![CDATA[<p> ​单调队列就是有排好序的队列，用于维护区间最值。以下面一题作为引入：</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个含有 $n$ 项的数列，求出每一项前的 $m$ 个数到它这个区间内的最小值。若前面的数不足 $m$ 项则从第 $1$ 个数开始，若前面没有数则输出 $0$。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数，分别表示 $n$，$m$。</p><p>第二行，$n$ 个正整数，为所给定的数列 $a_i$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>$n$ 行，每行一个整数，第 $i$ 个数为序列中 $a_i$ 之前 $m$ 个数的最小值。</p><h2 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例 #1"></a>输入输出样例 #1</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入 #1"></a>输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 2</span><br><span class="line">7 8 1 4 3 2</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出 #1"></a>输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">7</span><br><span class="line">7</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h2><p>对于 $100%$ 的数据，保证 $1\le m\le n\le2\times10^6$，$1\le a_i\le3\times10^7$。</p><p>​找每个区间最小值，可以用滑动窗口扫一遍。通常会想到set+map的组合，前者负责维护单调，后者维护元素个数，但时间复杂度为O(NlogN)，过不了题目的2e6。因此要想办法压到O(N)。<br>​现在设计一个单调队列，小的元素放前面，大的但是新的元素放后面。每次扫的新的元素时，将队列中比它大的元素弹出（其实并非真正弹出，但是留在队列中它们也会排在这个新元素之后，而且随着滑动窗口移动它们也会被弹出，对后续无任何影响，不如在现在就直接弹出），再将旧的元素弹出。每次找区间最小只需要找队首就可以了。<br>​因此设计一个结构体记录每个元素的数字大小和下标，具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  <span class="type">int</span> num, no;<span class="comment">//记录数字和下标</span></span><br><span class="line">&#125;arr[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; arr[i].num;</span><br><span class="line">    arr[i].no = i;</span><br><span class="line">  &#125;</span><br><span class="line">  deque &lt;node&gt; dq;</span><br><span class="line">  cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//对于第一个元素，他前面没有数字，一定会输出0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">  ​<span class="comment">//注意因为已经输出了第一个元素的答案0，所以接下来的操作都是i + 1的</span></span><br><span class="line">  ​<span class="comment">//i + 1的答案范围是[i + 1 - m, i]，因此要清除小于等于i - m的元素</span></span><br><span class="line">    <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>().no &lt;= i - m)&#123;</span><br><span class="line">      dq.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//维持队列单调性</span></span><br><span class="line">    <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">back</span>().num &gt; arr[i].num)&#123;</span><br><span class="line">      dq.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加新元素</span></span><br><span class="line">    dq.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">    <span class="comment">//注意这里输出的是i + 1的答案</span></span><br><span class="line">    cout &lt;&lt; dq.<span class="built_in">front</span>().num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这就是单调队列，可以在O(n)的时间复杂度之内完成所有固定长度区间的最值查找。<br>​接下来以一道例题来看下单调队列如何优化dp：</p><h1 id="P2034-选择数字"><a href="#P2034-选择数字" class="headerlink" title="P2034 选择数字"></a>P2034 选择数字</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一行 $n$ 个非负整数 $a_1 ,\cdots, a_n$。现在你可以选择其中若干个数，但不能有超过 $k$ 个连续的数字被选择。你的任务是使得选出的数字的和最大。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数 $n,k$。</p><p>以下 $n$ 行，每行一个整数表示 $a_i$。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个值表示答案。</p><h2 id="输入输出样例-1-1"><a href="#输入输出样例-1-1" class="headerlink" title="输入输出样例 #1"></a>输入输出样例 #1</h2><h3 id="输入-1-1"><a href="#输入-1-1" class="headerlink" title="输入 #1"></a>输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="输出-1-1"><a href="#输出-1-1" class="headerlink" title="输出 #1"></a>输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="说明-提示-1"><a href="#说明-提示-1" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h2><p>对于 $20%$ 的数据，$n \le 10$。</p><p>对于另外 $20%$ 的数据，$k&#x3D;1$。</p><p>对于 $60%$ 的数据，$n \le 10^3$。</p><p>对于 $100%$ 的数据，$1 \le n \le 10^5$，$1 \le k \le n$，$0 \le $ 数字大小 $ \le 10^9$。</p><p>时间限制 $500$ms。</p><p>​题目可以这样理解，每k个数就要删除一个，删除的一个数越小越好。这就可以看作是维护一个长度为k滑动窗口中的最小值，可以用单调队列来维护。同时设计dp数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ll dp[maxn][<span class="number">2</span>];<span class="comment">//dp[i][0]表示不取i，dp[i][1]表示取i</span></span><br><span class="line">ll he[maxn];<span class="comment">//前缀和</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);<span class="comment">//取前一个最大的</span></span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i][<span class="number">1</span>], dp[j][<span class="number">0</span>] + he[i] - he[j])(i - k &lt;= j &lt; i)<span class="comment">//不取j并且取j+1到i</span></span><br></pre></td></tr></table></figure><p>​两层循环i和j会TLE，这里要用单调队列维护的dp[j][0] - he[j]，将时间复杂度降到O(n)。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">ll he[maxn], dp[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    ll x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    he[i] = he[i - <span class="number">1</span>] + x;</span><br><span class="line">  &#125;</span><br><span class="line">  deque &lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">  dq.<span class="built_in">push_back</span>(<span class="number">0</span>);<span class="comment">//设置虚拟起始点0，保证队列不为空</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">  ​<span class="comment">//维护窗口区间</span></span><br><span class="line">    <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt; i - k)&#123;</span><br><span class="line">      dq.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = dp[dq.<span class="built_in">front</span>()][<span class="number">0</span>] - he[dq.<span class="built_in">front</span>()] + he[i];</span><br><span class="line">    <span class="comment">//维护单调性</span></span><br><span class="line">    <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dp[dq.<span class="built_in">back</span>()][<span class="number">0</span>] - he[dq.<span class="built_in">back</span>()] &lt; dp[i][<span class="number">0</span>] - he[i])&#123;</span><br><span class="line">      dq.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前元素添加进队列中，供后续元素使用</span></span><br><span class="line">    dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="comment">/*注意每次循环都是使用之前的元素，所以先状态转移再添加当前元素*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">max</span>(dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​​再放一道简单的题目：</p><h1 id="P3572-POI-2014-PTA-Little-Bird"><a href="#P3572-POI-2014-PTA-Little-Bird" class="headerlink" title="P3572 [POI 2014] PTA-Little Bird"></a>P3572 [POI 2014] PTA-Little Bird</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 $n$ 棵树排成一排，第 $i$ 棵树的高度是 $d_i$。</p><p>有 $q$ 只鸟要从第 $1$ 棵树到第 $n$ 棵树。</p><p>当第 $i$ 只鸟在第 $j$ 棵树时，它可以飞到第 $j+1, j+2, \cdots, j+k_i$ 棵树。</p><p>如果一只鸟飞到一颗高度大于等于当前树的树，那么它的劳累值会增加 $1$，否则不会。</p><p>由于这些鸟已经体力不支，所以它们想要最小化劳累值。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入 $n$。</p><p>第二行 $n$ 个数，第 $i$ 个数表示 $d_i$。</p><p>第三行输入 $q$。</p><p>接下来 $q$ 行，每一行一个整数，第 $i$ 行的整数为 $k_i$。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>共 $q$ 行，每一行输出第 $i$ 只鸟的最小劳累值。</p><h2 id="输入输出样例-1-2"><a href="#输入输出样例-1-2" class="headerlink" title="输入输出样例 #1"></a>输入输出样例 #1</h2><h3 id="输入-1-2"><a href="#输入-1-2" class="headerlink" title="输入 #1"></a>输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">4 6 3 6 3 7 2 6 5</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="输出-1-2"><a href="#输出-1-2" class="headerlink" title="输出 #1"></a>输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="说明-提示-2"><a href="#说明-提示-2" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h2><p>$1 \le n \le 10^6$，$1 \le d_i \le 10^9$，$1 \le q \le 25$，$1 \le k_i \le n - 1$。<br>​​先看状态方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = i - k; j &lt;= i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">    dp[i] = <span class="built_in">min</span>(dp[i], dp[j] + (arr[j] &gt; arr[i] ? <span class="number">0</span> : <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​直接上代码解释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line">ll arr[maxn], dp[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  cin &gt;&gt; q;</span><br><span class="line">  <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    deque &lt;<span class="type">int</span>&gt; dq;<span class="comment">//单调队列求树i之前最小劳累度</span></span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="number">1</span>);<span class="comment">//起始在树1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    ​  <span class="comment">//维护窗口区间</span></span><br><span class="line">      <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt; i - k)&#123;</span><br><span class="line">        dq.<span class="built_in">pop_front</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//dq.front树更高，不用加劳累度</span></span><br><span class="line">      <span class="keyword">if</span> (arr[dq.<span class="built_in">front</span>()] &gt; arr[i]) dp[i] = dp[dq.<span class="built_in">front</span>()];</span><br><span class="line">      <span class="comment">//否则加1</span></span><br><span class="line">      <span class="keyword">else</span> dp[i] = dp[dq.<span class="built_in">front</span>()] + <span class="number">1</span>;</span><br><span class="line">      ​​​​​​<span class="comment">//劳累度 + 旧树是否比当前树高？</span></span><br><span class="line">      <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dp[dq.<span class="built_in">back</span>()] + (arr[dq.<span class="built_in">back</span>()] &gt; arr[i] ? <span class="number">0</span> : <span class="number">1</span>) &gt; dp[i])&#123;</span><br><span class="line">        dq.<span class="built_in">pop_back</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​总结，当dp出现了从i之前的一段区间内的最值转移到i，可以用单调队列优化，不用多开一个循环遍历区间寻找最值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链式队列</title>
      <link href="/2025/10/27/%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97/"/>
      <url>/2025/10/27/%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> * PtrToNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123; <span class="comment">//元素节点</span></span><br><span class="line">  ElementType Data;</span><br><span class="line">  PtrToNode Next;<span class="comment">//链式存储</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span> *PtrToQNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QNode</span>&#123;</span><br><span class="line">  Position Front, Rear;<span class="comment">//头节点和尾节点</span></span><br><span class="line">  <span class="type">int</span> Maxsize, CurSize;<span class="comment">//记录大小</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToQNode Queue;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue <span class="title">createQueue</span><span class="params">(<span class="type">int</span> MaxSize)</span></span>&#123;</span><br><span class="line">  Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">  Q-&gt;Front = Q-&gt;Rear = <span class="literal">NULL</span>;</span><br><span class="line">  Q-&gt;Maxsize = MaxSize;</span><br><span class="line">  Q-&gt;CurSize = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isfull</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Q-&gt;CurSize == Q-&gt;Maxsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;Front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Queue Q, ElementType X)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isfull</span>(Q))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FULL\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Position new_p = (Position)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">  new_p-&gt;Data = X;</span><br><span class="line">  new_p-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isempty</span>(Q))&#123;</span><br><span class="line">    Q-&gt;Front = Q-&gt;Rear = new_p;<span class="comment">//如果Q为空，头尾元素均为它</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Q-&gt;Rear-&gt;Next = new_p;<span class="comment">//否则插入到尾节点后</span></span><br><span class="line">    Q-&gt;Rear = new_p;<span class="comment">//更新尾节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  Q-&gt;CurSize++;<span class="comment">//数量++</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">pop</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">  Position frontcell;</span><br><span class="line">  ElementType element;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isempty</span>(Q))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;EMPTY\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  frontcell = Q-&gt;Front;</span><br><span class="line">  <span class="keyword">if</span> (Q-&gt;Front == Q-&gt;Rear)&#123;<span class="comment">//如果只有一个元素</span></span><br><span class="line">    Q-&gt;Front = Q-&gt;Rear = <span class="literal">NULL</span>;<span class="comment">//头尾都设置为full</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Q-&gt;Front = Q-&gt;Front-&gt;Next;<span class="comment">//否则只删除头节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  element = frontcell-&gt;Data;</span><br><span class="line">  <span class="built_in">free</span>(frontcell);<span class="comment">//释放空间</span></span><br><span class="line">  Q-&gt;CurSize--;<span class="comment">//减少数量</span></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 特殊线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环队列</title>
      <link href="/2025/10/27/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
      <url>/2025/10/27/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span> * PtrToQNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QNode</span>&#123;</span><br><span class="line">  ElementType * Data;</span><br><span class="line">  Position Front, Rear;</span><br><span class="line">  <span class="type">int</span> MaxSize;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToQNode Queue;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue <span class="title">CreateQueue</span><span class="params">(<span class="type">int</span> MaxSize)</span></span>&#123;</span><br><span class="line">  Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">  Q-&gt;Data = (ElementType *)<span class="built_in">malloc</span>(MaxSize * <span class="built_in">sizeof</span>(ElementType));</span><br><span class="line">  Q-&gt;Front = Q-&gt;Rear = <span class="number">0</span>;</span><br><span class="line">  Q-&gt;MaxSize = MaxSize;</span><br><span class="line">  <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isfull</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((Q-&gt;Rear + <span class="number">1</span>) % Q-&gt;MaxSize == Q-&gt;Front);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Queue Q, ElementType X)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isfull</span>(Q))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FULL\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Q-&gt;Rear = (Q-&gt;Rear + <span class="number">1</span>) % Q-&gt;MaxSize;</span><br><span class="line">  Q-&gt;Data[Q-&gt;Rear] = X;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Q-&gt;Front == Q-&gt;Rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">pop</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isempty</span>(Q))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;EMPTY\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> element = Q-&gt;Data[Q-&gt;Front];</span><br><span class="line">  Q-&gt;Front = (Q-&gt;Front + <span class="number">1</span>) % Q-&gt;MaxSize;</span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 特殊线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带头节点的链栈</title>
      <link href="/2025/10/27/%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E6%A0%88/"/>
      <url>/2025/10/27/%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SNode</span> *PtrToSNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SNode</span>&#123;</span><br><span class="line">  ElementType Data;<span class="comment">//元素</span></span><br><span class="line">  PtrToSNode Next;<span class="comment">//下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToSNode Stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Stack S, ElementType X)</span></span>&#123;<span class="comment">//在头节点S与S-&gt;Next之间插入新元素</span></span><br><span class="line">  PtrToSNode new_p = (PtrToSNode)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> SNode));</span><br><span class="line">  new_p-&gt;Data = X;</span><br><span class="line">  new_p-&gt;Next = S-&gt;Next;</span><br><span class="line">  S-&gt;Next = new_p;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">pop</span><span class="params">(Stack S)</span></span>&#123;<span class="comment">//删除S-&gt;Next</span></span><br><span class="line">  <span class="keyword">if</span> (S-&gt;Next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;EMPTY\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  PtrToSNode cur_top = S-&gt;Next;</span><br><span class="line">  <span class="type">int</span> element = cur_top-&gt;Data;</span><br><span class="line">  S-&gt;Next = cur_top-&gt;Next;</span><br><span class="line">  <span class="built_in">free</span>(cur_top);<span class="comment">//释放空间</span></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 特殊线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序栈</title>
      <link href="/2025/10/27/%E9%A1%BA%E5%BA%8F%E6%A0%88/"/>
      <url>/2025/10/27/%E9%A1%BA%E5%BA%8F%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SNode</span> * PtrToSNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SNode</span>&#123;</span><br><span class="line">  ElementType * Data;<span class="comment">//动态数组</span></span><br><span class="line">  Position Top;<span class="comment">//栈顶</span></span><br><span class="line">  <span class="type">int</span> MaxSize;<span class="comment">//最大容量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToSNode Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">(<span class="type">int</span> MaxSize)</span></span>&#123;</span><br><span class="line">  Stack S = (Stack)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> SNode));<span class="comment">//初始化一个栈</span></span><br><span class="line">  S-&gt;Data = (ElementType *)<span class="built_in">malloc</span>(MaxSize * <span class="built_in">sizeof</span>(ElementType));<span class="comment">//给动态数组初始化大小</span></span><br><span class="line">  S-&gt;Top = <span class="number">-1</span>;<span class="comment">//栈顶初始化为1，代表没有元素</span></span><br><span class="line">  S-&gt;MaxSize = MaxSize;<span class="comment">//赋值栈的容量</span></span><br><span class="line">  <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isfull</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> S-&gt;Top == S-&gt;MaxSize - <span class="number">1</span>;<span class="comment">//数组满了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Stack S, ElementType X)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isfull</span>(S))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FULL!!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  S-&gt;Data[++S-&gt;Top] = X;<span class="comment">//先加top再赋值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> S-&gt;Top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">pop</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isempty</span>(S))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;EMPTY!!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> S-&gt;Data[S-&gt;Top--];<span class="comment">//先吐出元素再减top</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 特殊线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在一个数组中实现两个堆栈</title>
      <link href="/2025/10/27/%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%A0%86%E6%A0%88/"/>
      <url>/2025/10/27/%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%A0%86%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>本题要求在一个数组中实现两个堆栈。</p><h3 id="函数接口定义："><a href="#函数接口定义：" class="headerlink" title="函数接口定义："></a>函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">( <span class="type">int</span> MaxSize )</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">( Stack S, ElementType X, <span class="type">int</span> Tag )</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">( Stack S, <span class="type">int</span> Tag )</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>Tag</code>是堆栈编号，取1或2；<code>MaxSize</code>堆栈数组的规模；<code>Stack</code>结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Position;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SNode</span> &#123;</span><br><span class="line">    ElementType *Data;</span><br><span class="line">    Position Top1, Top2;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SNode</span> *Stack;</span><br></pre></td></tr></table></figure><p>注意：如果堆栈已满，<code>Push</code>函数必须输出“Stack Full”并且返回false；如果某堆栈是空的，则<code>Pop</code>函数必须输出“Stack Tag Empty”（其中Tag是该堆栈的编号），并且返回ERROR。</p><h3 id="裁判测试程序样例："><a href="#裁判测试程序样例：" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 1e8</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; push, pop, end &#125; Operation;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; <span class="literal">false</span>, <span class="literal">true</span> &#125; <span class="type">bool</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Position;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SNode</span> &#123;</span><br><span class="line">    ElementType *Data;</span><br><span class="line">    Position Top1, Top2;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SNode</span> *Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">( <span class="type">int</span> MaxSize )</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">( Stack S, ElementType X, <span class="type">int</span> Tag )</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">( Stack S, <span class="type">int</span> Tag )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Operation <span class="title">GetOp</span><span class="params">()</span></span>;  <span class="comment">/* details omitted */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintStack</span><span class="params">( Stack S, <span class="type">int</span> Tag )</span></span>; <span class="comment">/* details omitted */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N, Tag, X;</span><br><span class="line">    Stack S;</span><br><span class="line">    <span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    S = <span class="built_in">CreateStack</span>(N);</span><br><span class="line">    <span class="keyword">while</span> ( !done ) &#123;</span><br><span class="line">        <span class="keyword">switch</span>( <span class="built_in">GetOp</span>() ) &#123;</span><br><span class="line">        <span class="keyword">case</span> push: </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;Tag, &amp;X);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">Push</span>(S, X, Tag)) <span class="built_in">printf</span>(<span class="string">&quot;Stack %d is Full!\n&quot;</span>, Tag);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> pop:</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Tag);</span><br><span class="line">            X = <span class="built_in">Pop</span>(S, Tag);</span><br><span class="line">            <span class="keyword">if</span> ( X==ERROR ) <span class="built_in">printf</span>(<span class="string">&quot;Stack %d is Empty!\n&quot;</span>, Tag);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> end:</span><br><span class="line">            <span class="built_in">PrintStack</span>(S, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">PrintStack</span>(S, <span class="number">2</span>);</span><br><span class="line">            done = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">Push 1 1</span><br><span class="line">Pop 2</span><br><span class="line">Push 2 11</span><br><span class="line">Push 1 2</span><br><span class="line">Push 2 12</span><br><span class="line">Pop 1</span><br><span class="line">Push 2 13</span><br><span class="line">Push 2 14</span><br><span class="line">Push 1 3</span><br><span class="line">Pop 2</span><br><span class="line">End</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack 2 Empty</span><br><span class="line">Stack 2 is Empty!</span><br><span class="line">Stack Full</span><br><span class="line">Stack 1 is Full!</span><br><span class="line">Pop from Stack 1: 1</span><br><span class="line">Pop from Stack 2: 13 12 11</span><br></pre></td></tr></table></figure><p>代码长度限制</p><p>16 KB</p><p>时间限制</p><p>400 ms</p><p>内存限制</p><p>64 MB</p><p>​也是个脑抽的题目，为什么我非要在一个数组里定义两个堆栈？而且在一个数组里定义两个堆栈，又不给我内存空间使用的标准，那我怎么定义？要我猜吗？</p><p>​别说，真靠猜，下面是完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">( <span class="type">int</span> MaxSize )</span></span>&#123;</span><br><span class="line">  Stack head = (Stack)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> SNode));<span class="comment">//定义头节点</span></span><br><span class="line">  head-&gt;Data = (ElementType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElementType) * MaxSize);<span class="comment">//开数组</span></span><br><span class="line">  head-&gt;MaxSize = MaxSize;</span><br><span class="line">  head-&gt;Top1 = <span class="number">-1</span>;<span class="comment">//一号堆栈从0开始</span></span><br><span class="line">  head-&gt;Top2 = MaxSize; <span class="comment">//二号堆栈从末尾开始</span></span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">( Stack S,ElementType X, <span class="type">int</span> Tag )</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (S-&gt;Top1 + <span class="number">1</span> == S-&gt;Top2)&#123;<span class="comment">//两个堆栈相遇，表示数组满了</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack Full\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Tag == <span class="number">1</span>)&#123;<span class="comment">//tag1，一号栈添加元素</span></span><br><span class="line">    S-&gt;Data[++S-&gt;Top1] = X;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;<span class="comment">//tag2，二号栈添加元素</span></span><br><span class="line">    S-&gt;Data[--S-&gt;Top2] = X;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">( Stack S, <span class="type">int</span> Tag )</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Tag == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;Top1 == <span class="number">-1</span>)&#123;<span class="comment">//一号堆栈为空</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Stack %d Empty\n&quot;</span>, Tag);</span><br><span class="line">      <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;Data[S-&gt;Top1--];<span class="comment">//指针前移</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;Top2 == S-&gt;MaxSize)&#123;<span class="comment">//二号堆栈为空</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Stack %d Empty\n&quot;</span>, Tag);</span><br><span class="line">      <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;Data[S-&gt;Top2++];<span class="comment">//指针后移</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中缀表达式转后缀表达式</title>
      <link href="/2025/10/27/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/10/27/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<pre><code>用于算式计算，需要注意处理以下六种情况：1、空格不处理2、运算数直接输出3、左括号直接压入栈4、右括号，不断输出栈顶元素并出栈，直到遇见左括号5、运算符，优先级大于栈顶运算符时直接入栈，否则不断输出栈顶元素并出栈直到优先级大于栈顶运算符或则空栈。6、处理完成，将栈中剩余运算符一并输出</code></pre><p>只要知道规则就简单了，看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bit/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 特殊线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树】完全二叉树后序变层序</title>
      <link href="/2025/10/23/%E3%80%90%E6%A0%91%E3%80%91%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E5%8F%98%E5%B1%82%E5%BA%8F/"/>
      <url>/2025/10/23/%E3%80%90%E6%A0%91%E3%80%91%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E5%8F%98%E5%B1%82%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是<strong>完美二叉树</strong>。对于深度为 <em>D</em> 的，有 <em>N</em> 个结点的二叉树，若其结点对应于相同深度完美二叉树的层序遍历的前 <em>N</em> 个结点，这样的树就是<strong>完全二叉树</strong>。</p><p>给定一棵完全二叉树的后序遍历，请你给出这棵树的层序遍历结果。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出正整数 <em>N</em>（≤30），即树中结点个数。第二行给出后序遍历序列，为 <em>N</em> 个不超过 100 的正整数。同一行中所有数字都以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出该树的层序遍历序列。所有数字都以 1 个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">91 71 2 34 10 15 55 18</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18 34 55 71 2 10 15 91</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, w[<span class="number">10010</span>],ans[<span class="number">10010</span>], id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt; n) <span class="keyword">return</span> ;</span><br><span class="line">  <span class="built_in">dfs</span>(pos &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">dfs</span>((pos &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">  ans[pos] = w[++id];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; w[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;cout &lt;&lt; ans[n];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【状压dp】猛兽动物园</title>
      <link href="/2025/10/22/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91%E7%8C%9B%E5%85%BD%E5%8A%A8%E7%89%A9%E5%9B%AD/"/>
      <url>/2025/10/22/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91%E7%8C%9B%E5%85%BD%E5%8A%A8%E7%89%A9%E5%9B%AD/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>张琪曼惊喜道：“哇，抓到这么多猛兽，把它们都关到动物园吧。不过这个牙齿锋利的狮子好可怕啊。”</p><p>楚继光：“我倒不觉得，看那头鬃毛多可爱啊，不过这大猩猩太难看了。”</p><p>现在这些猛兽都被关在魔法世界的圆形动物园，圆形动物园包含一大圈围栏，每个围栏里有一种动物，有K个小朋友站在大围栏圈的外面，可以看到连续的5个围栏。每个小朋友有喜欢和害怕的动物。当下面两处情况之一发生时，小朋友就会高兴：</p><p>至少有一个他害怕的动物被移走；</p><p>至少有一个他喜欢的动物没被移走。</p><p>你可以选择将一些动物从围栏中移走以使得小朋友不会害怕。但你不能移走所有的动物，否则小朋友们就没有动物可看了。</p><p>例如，考虑图中的小伙伴和动物：<br><img src="http://180.201.136.244/upload/image/20160707/20160707112504_65750.png" alt="img"><img src="http://180.201.136.244/upload/image/20160707/20160707112514_74938.png" alt="img"><br>假如你将围栏4和12的动物移走，Alex和Ka-Shu将很高兴，因为至少有一个他们害怕的动物被移走了。这也会使Chaitanya高兴，因为他喜欢的围栏6和8中的动物都保留了。但是，Polly和Hwan将不高兴，因为他们看不到任何他们喜欢的动物，而他们害怕的动物都还在。这种安排方式使得三个小朋友高兴。</p><p>现在，换一种方法，如果你将围栏4和6中的动物移走，Alex和Polly将很高兴，因为他们害怕的动物被移走了。Chaitanya也会高兴，虽然他喜欢的动物6被移走了，他仍可以看到围栏8里面他喜欢的动物。同样的Hwan也会因可以看到自己喜欢的动物12而高兴。唯一不高兴的只有Ka-Shu。</p><p>如果你只移走围栏13中的动物，Ka-Shu将高兴，因为有一个他害怕的动物被移走了，Alex， Polly，Chaitanya和Hwan也会高兴，因为他们都可以看到至少一个他们喜欢的动物。所以有5个小朋友会高兴。这种方法使得最多的小朋友高兴。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含两个整数N，C，用空格分隔。N是围栏数(1≤N≤10 000)，C是小朋友的个数(1≤C≤50 000)。围栏按照顺时针的方向编号为1，2，3，…，N。</p><p>接下来的C行，每行描述一个小朋友，描述下面的形式给出： E F L X1 X2 …XF Y1 Y2 … YL 其中：</p><p>E表示小朋友可以看到的第一个围栏的编号(1≤E≤N)，也就是说，小朋友可以看到的围栏为E，E+1，E+2，E+3，E+4。注意，如果编号超过N将继续从1开始算。如：当N&#x3D;14，E&#x3D;13时，小朋友可以看到的围栏为13，14，1，2和3。</p><p>F表示小朋友害怕的动物数。L表示小朋友喜欢的动物数。 围栏X1，X2，…， XF中包含小朋友害怕的动物。 围栏Y1，Y2，…， YL中包含该小朋友喜欢的动物。</p><p>X1， X2，…，XF， Y1， Y2，…YL是两两不同的数，而且所表示的围栏都是小朋友可以看到的。</p><p>小朋友已经按照他们可以看到的第一个围栏的编号从小到大的顺序排好了(这样最小的E对应的小朋友排在第一个，最大的E对应的小朋友排在最后一个)。注意可能有多于一个小朋友对应的E是相同的。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>仅输出一个数，表示最多可以让多少个小朋友高兴。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 10</span><br><span class="line">1 1 1 3 2</span><br><span class="line">2 1 0 4</span><br><span class="line">3 1 1 5 6</span><br><span class="line">4 1 1 7 6</span><br><span class="line">5 1 0 6</span><br><span class="line">6 1 2 9 8 10</span><br><span class="line">7 1 0 10</span><br><span class="line">8 1 0 8</span><br><span class="line">9 1 1 1 2</span><br><span class="line">10 1 0 2</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>​注意每个小朋友只能看到连续的五个围栏，因此可以这样定义dp数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> State = ( <span class="number">1</span> &lt;&lt; <span class="number">5</span> ) - <span class="number">1</span> ; </span><br><span class="line"><span class="type">int</span> dp[ N ][ State + <span class="number">1</span> ] ;  </span><br><span class="line"><span class="comment">// DP数组，dp[i][j]表示处理到第i个围栏且状态为j时的最大高兴小朋友数</span></span><br><span class="line"><span class="type">int</span> b[ N ][ State + <span class="number">1</span> ] ; </span><br><span class="line"><span class="comment">// b[i][j]表示在第i个位置，状态为j时会高兴的小朋友数量</span></span><br></pre></td></tr></table></figure><p>​对于每个小朋友，需要构建令它高兴的mask：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  <span class="type">int</span> left, right;<span class="comment">//围栏起点编号和终点编号</span></span><br><span class="line">  <span class="type">int</span> num_f, num_af;<span class="comment">//喜欢的动物数量和害怕的动物数量</span></span><br><span class="line">  <span class="type">int</span> f[<span class="number">10</span>], af[<span class="number">10</span>];<span class="comment">//记录具体喜欢和害怕的动物</span></span><br><span class="line">&#125;a[C];</span><br></pre></td></tr></table></figure><p>​对于状态转移，当前状态由前一个状态左移一位得到（去掉最高位，最低位可以是0或1）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;<span class="comment">//处理每一个围栏</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= State; j++)&#123;<span class="comment">//枚举状态</span></span><br><span class="line">    <span class="comment">//15 的二进制是 01111（低4位为1，最高位为0）</span></span><br><span class="line">    <span class="comment">//j &amp; 15 的作用是保留状态j的低4位，清除最高位</span></span><br><span class="line">    <span class="comment">//左移一位，相当于所有位向左移动，最低位补0</span></span><br><span class="line">    <span class="comment">// | 1，将最低位变为1</span></span><br><span class="line">    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][((j &amp; (<span class="number">15</span>)) &lt;&lt; <span class="number">1</span>)], </span><br><span class="line">    dp[i - <span class="number">1</span>][((j &amp; (<span class="number">15</span>)) &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)]) + b[i][j];</span><br><span class="line">      <span class="comment">//前一个状态加上当前状态下高兴的小朋友的数量；</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​下面是完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> C = <span class="number">5e4</span> + <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> State = (<span class="number">1</span> &lt;&lt; <span class="number">5</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  <span class="type">int</span> left, right;<span class="comment">//围栏起点编号和终点编号</span></span><br><span class="line">  <span class="type">int</span> num_f, num_af;<span class="comment">//喜欢的动物数量和害怕的动物数量</span></span><br><span class="line">  <span class="type">int</span> f[<span class="number">10</span>], af[<span class="number">10</span>];<span class="comment">//记录具体喜欢和害怕的动物</span></span><br><span class="line">&#125;a[C];</span><br><span class="line"><span class="type">int</span> dp[N][State + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// DP数组，dp[i][j]表示处理到第i个围栏且状态为j时的最大高兴小朋友数</span></span><br><span class="line"><span class="type">int</span> b[N][State + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// b[i][j]表示在第i个位置，状态为j时会高兴的小朋友数量</span></span><br><span class="line"><span class="type">int</span> pa = <span class="number">0</span>, ai = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//怕，爱</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;<span class="comment">//处理每个小朋友</span></span><br><span class="line">    cin &gt;&gt; a[i].left;<span class="comment">//围栏起点</span></span><br><span class="line">    pa = <span class="number">0</span>, ai = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; a[i].num_af &gt;&gt; a[i].num_f;</span><br><span class="line">    <span class="comment">//处理害怕动物</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= a[i].num_af; j++)&#123;</span><br><span class="line">      cin &gt;&gt; a[i].af[j];</span><br><span class="line">      <span class="comment">//计算该害怕动物在五个连续围栏中的相对位置</span></span><br><span class="line">      <span class="type">int</span> pp = (a[i].af[j] - a[i].left + n) % n;</span><br><span class="line">      pa |= (<span class="number">1</span> &lt;&lt; pp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理喜欢的动物</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= a[i].num_f; j++)&#123;</span><br><span class="line">      cin &gt;&gt; a[i].f[j];</span><br><span class="line">      <span class="comment">//计算该喜欢动物在五个连续围栏中的相对位置</span></span><br><span class="line">      <span class="type">int</span> pp = (a[i].f[j] - a[i].left + n) % n;</span><br><span class="line">      ai |= (<span class="number">1</span> &lt;&lt; pp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//枚举所有状态，检查哪些可以使小朋友高兴</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= State; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> ((j &amp; pa) || ((~j) &amp; ai))&#123;</span><br><span class="line">        b[a[i].left][j]++;<span class="comment">//该状态下高兴的小朋友++</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">-1e9</span>;</span><br><span class="line">  <span class="comment">//枚举所有可能的初始状态，注意动物园是环形的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt;= State; mask++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp[<span class="number">0</span>], <span class="number">128</span>, <span class="built_in">sizeof</span>(dp[<span class="number">0</span>]));<span class="comment">//初始化dp为极小值</span></span><br><span class="line">    dp[<span class="number">0</span>][mask] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//处理每一个围栏</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= State; j++)&#123;<span class="comment">//枚举状态</span></span><br><span class="line">        <span class="comment">//15 的二进制是 01111（低4位为1，最高位为0）</span></span><br><span class="line">        <span class="comment">//j &amp; 15 的作用是保留状态j的低4位，清除最高位</span></span><br><span class="line">        <span class="comment">//左移一位，相当于所有位向左移动，最低位补0</span></span><br><span class="line">        <span class="comment">// | 1，将最低位变为1</span></span><br><span class="line">        dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][((j &amp; (<span class="number">15</span>)) &lt;&lt; <span class="number">1</span>)], dp[i - <span class="number">1</span>][((j &amp; (<span class="number">15</span>)) &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)]) + b[i][j];<span class="comment">//前一个状态加上当前状态下高兴的小朋友的数量；</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, dp[n][mask]);<span class="comment">//更新答案</span></span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【状压dp】炮兵阵地</title>
      <link href="/2025/10/22/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0/"/>
      <url>/2025/10/22/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>魔法学院打算在N×M的网格地图上部署炮兵部队以对抗猛兽军团。一个N×M的地图由N行M列组成，地图的每一格可能是山地（用“H”表示），也可能是平原（用“P”表示），如图所示。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围为图中黑色区域。</p><p><img src="http://180.201.136.244/upload/image/20170930/20170930180818_86137.jpg" alt="img"></p><p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其他白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。<br>现在，魔法学院规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少炮兵部队。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行包含两个由空格分割开的正整数，分别表示N和M。<br>接下来的N行，每一行含有连续的M个字符(P或者H)，中间没有空格。按顺序表示地图中每一行的数据。N≤ 100；M ≤ 10。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>仅一行，包含一个整数K，表示最多能摆放的炮兵部队的数量。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">PHPP</span><br><span class="line">PPHH</span><br><span class="line">PPPP</span><br><span class="line">PHPP</span><br><span class="line">PHHP</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>​这题的难点在于一行的mask与上下两行相关，在行与行之间转移时还要考虑上两行的mask。这里可以开三维dp来解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll dp[<span class="number">110</span>][<span class="number">100</span>][<span class="number">100</span>]；<span class="comment">//行，当前行mask，上一行mask</span></span><br></pre></td></tr></table></figure><p>​这样状态转移时就可以顾及到上两行的情况了。</p><p>​完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = (<span class="number">1</span> &lt;&lt; <span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll dp[<span class="number">110</span>][<span class="number">100</span>][<span class="number">100</span>],value[maxn];<span class="comment">//value记录mask中有多少个1</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">110</span>];<span class="comment">//记录地形的mask</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; hefa_mask;<span class="comment">//记录不考虑地形的合法mask，减少时间复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;<span class="comment">//预处理不考虑地形的合法mask</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; m); mask++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; (mask &gt;&gt; <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; (mask &lt;&lt; <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; (mask &gt;&gt; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; (mask &lt;&lt; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">    hefa_mask.<span class="built_in">push_back</span>(mask);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//记录mask中有多少个1</span></span><br><span class="line">  <span class="keyword">if</span> (value[x] != <span class="number">-1</span>) <span class="keyword">return</span> value[x];</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>, X = x;</span><br><span class="line">  <span class="keyword">while</span>(x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">1</span>) ans++;</span><br><span class="line">    x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  value[X] = ans;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_mask</span><span class="params">(<span class="type">int</span> I)</span></span>&#123;<span class="comment">//将地形变为mask</span></span><br><span class="line">  string temp;</span><br><span class="line">  cin &gt;&gt; temp;</span><br><span class="line">  <span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp[i] == <span class="string">&#x27;P&#x27;</span>)&#123;</span><br><span class="line">      mask |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[I] = mask;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mask, <span class="type">int</span> I)</span></span>&#123;</span><br><span class="line">  <span class="comment">//检查当前mask是否与所在行的地形冲突</span></span><br><span class="line">  <span class="comment">//mask中一位为1，地形mask对应位为0</span></span><br><span class="line">  <span class="keyword">if</span> ((mask &amp; (~arr[I])) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(value, <span class="number">-1</span>, <span class="built_in">sizeof</span>(value));</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">pre</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="built_in">build_mask</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> cnt = hefa_mask.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">//处理第一行</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> m1 = <span class="number">0</span>; m1 &lt; cnt; m1++)&#123;</span><br><span class="line">    <span class="type">int</span> mask = hefa_mask[m1];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mask, <span class="number">1</span>))&#123;</span><br><span class="line">      dp[<span class="number">1</span>][m1][<span class="number">0</span>] = <span class="built_in">get_sum</span>(mask);</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, dp[<span class="number">1</span>][m1][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果只有第一行，直接输出答案</span></span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理第二行</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> m0 = <span class="number">0</span>; m0 &lt; cnt; m0++)&#123;</span><br><span class="line">    <span class="type">int</span> mask = hefa_mask[m0];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">check</span>(mask, <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m1 = <span class="number">0</span>; m1 &lt; cnt; m1++)&#123;</span><br><span class="line">      <span class="type">int</span> mask1 = hefa_mask[m1];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">check</span>(mask1, <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (mask &amp; mask1) <span class="keyword">continue</span>;<span class="comment">//mask与mask1不能冲突</span></span><br><span class="line">      dp[<span class="number">2</span>][m0][m1] = <span class="built_in">get_sum</span>(mask1) + <span class="built_in">get_sum</span>(mask);</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, dp[<span class="number">2</span>][m0][m1]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//预处理了两行，处理剩余的行</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m0 = <span class="number">0</span>; m0 &lt; cnt; m0++)&#123;</span><br><span class="line">      <span class="type">int</span> mask = hefa_mask[m0];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">check</span>(mask, i)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> m1 = <span class="number">0</span>; m1 &lt; cnt; m1++)&#123;</span><br><span class="line">        <span class="type">int</span> mask1 = hefa_mask[m1];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check</span>(mask1, i - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (mask &amp; mask1) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m2 = <span class="number">0</span>; m2 &lt; cnt; m2++)&#123;</span><br><span class="line">          <span class="type">int</span> mask2 = hefa_mask[m2];</span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">check</span>(mask2, i - <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">if</span> (mask1 &amp; mask2) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">if</span> (mask &amp; mask2) <span class="keyword">continue</span>;</span><br><span class="line">          dp[i][m0][m1] = <span class="built_in">max</span>(dp[i][m0][m1], dp[i - <span class="number">1</span>][m1][m2] + <span class="built_in">get_sum</span>(mask));</span><br><span class="line">          ans = <span class="built_in">max</span>(ans, dp[i][m0][m1]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//其实不用下面的代码了</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> m0 = <span class="number">0</span>; m0 &lt; cnt; m0++)&#123;</span><br><span class="line">    <span class="type">int</span> mask = hefa_mask[m0];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">check</span>(mask, n)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m1 = <span class="number">0</span>; m1 &lt; cnt; m1++)&#123;</span><br><span class="line">      <span class="type">int</span> mask1 = hefa_mask[m1];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">check</span>(mask1, n - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (mask &amp; mask1) <span class="keyword">continue</span>;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, dp[n][m0][m1]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【状压dp】涂抹果酱</title>
      <link href="/2025/10/22/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91%E6%B6%82%E6%8A%B9%E6%9E%9C%E9%85%B1/"/>
      <url>/2025/10/22/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91%E6%B6%82%E6%8A%B9%E6%9E%9C%E9%85%B1/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Tyvj 两周年庆典要到了，Sam 想为 Tyvj 做一个大蛋糕。蛋糕俯视图是一个 N×M 的矩形，它被划分成 N×M 个边长为 1×1 的小正方形区域（可以把蛋糕当成 N 行 M 列的矩阵）。蛋糕很快做好了，但光秃秃的蛋糕肯定不好看！所以，Sam 要在蛋糕的上表面涂抹果酱。果酱有三种，分别是红果酱、绿果酱、蓝果酱，三种果酱的编号分别为 1,2,3。为了保证蛋糕的视觉效果，Admin 下达了死命令：相邻的区域严禁使用同种果酱。但 Sam 在接到这条命令之前，已经涂好了蛋糕第 K 行的果酱，且无法修改。<br>现在 Sam 想知道：能令 Admin 满意的涂果酱方案有多少种。请输出方案数 mod 106。若不存在满足条件的方案，请输出0。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入共三行。<br>第一行：N,M；<br>第二行：K；<br>第三行：M个整数，表示第K行的方案。<br>字母的详细含义见题目描述，其他参见样例。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出仅一行，为可行的方案总数。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 2 </span><br><span class="line">1 </span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p><img src="http://180.201.136.244/upload/image/20180802/20180802162857_89490.jpg" alt="img"><br>对于30%的数据，1≤N×M≤20；<br>对于60%的数据，1≤N≤1000,1≤M≤3；<br>对于100%的数据，1≤N≤10000,1≤M≤5。</p><p>​原本是一道简单的状压dp，从第k行开始向上下扫。不过由于有三种颜色所以不能用01串来表示mask，而用字符串来表示mask容易爆内存，因此用3进制来表示mask。比较奇怪的是我的代码会超时，被ai奇奇怪怪优化后才过的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">const</span> ll maxn = (<span class="number">1</span> &lt;&lt; <span class="number">5</span>) + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line">string s;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">unordered_map&lt;ll, ll&gt; p;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;<span class="comment">//判断a，b在相邻位置上是否有相同涂色</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> ((a % <span class="number">3</span>) == (b % <span class="number">3</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    a /= <span class="number">3</span>;</span><br><span class="line">    b /= <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">str_to_int</span><span class="params">(string s)</span></span>&#123;<span class="comment">//字符串转mask</span></span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> c : s)&#123;</span><br><span class="line">    res = res * <span class="number">3</span> + (c - <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_dfs</span><span class="params">()</span></span>&#123;<span class="comment">//预处理单行合法mask</span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">length</span>() == m)&#123;</span><br><span class="line">    <span class="type">int</span> mask = <span class="built_in">str_to_int</span>(s);</span><br><span class="line">    arr.<span class="built_in">push_back</span>(mask);</span><br><span class="line">    p[mask] = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="type">char</span> c = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">      s.<span class="built_in">push_back</span>(c);</span><br><span class="line">      <span class="built_in">pre_dfs</span>();</span><br><span class="line">      s.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">back</span>() != c)&#123;</span><br><span class="line">        s.<span class="built_in">push_back</span>(c);</span><br><span class="line">        <span class="built_in">pre_dfs</span>();</span><br><span class="line">        s.<span class="built_in">pop_back</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector &lt;ll&gt; dp[<span class="number">3</span>];<span class="comment">//滚动数组，之前爆内存爆怕了</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; last, cur;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  ll A = <span class="number">0</span>, B = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">  <span class="built_in">pre_dfs</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;<span class="comment">//根据单行合法数量重设dp大小</span></span><br><span class="line">    dp[i].<span class="built_in">resize</span>(arr.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  string sk;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    sk.<span class="built_in">push_back</span>(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> start_state = <span class="built_in">str_to_int</span>(sk);<span class="comment">//第k行mask</span></span><br><span class="line">  <span class="keyword">if</span> (p.<span class="built_in">find</span>(start_state) == p.<span class="built_in">end</span>())&#123;<span class="comment">//第k行不合法，直接输出0</span></span><br><span class="line">    cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> start_id = p[start_state];</span><br><span class="line">  last.<span class="built_in">push_back</span>(start_id);</span><br><span class="line">  dp[<span class="number">1</span>][start_id] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">    cur.<span class="built_in">clear</span>();</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; cur_set;<span class="comment">//用set去重</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; arr.<span class="built_in">size</span>(); mask++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> old_mask : last)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check</span>(arr[mask], arr[old_mask])) <span class="keyword">continue</span>;</span><br><span class="line">        dp[<span class="number">0</span>][mask] += dp[<span class="number">1</span>][old_mask];</span><br><span class="line">        dp[<span class="number">0</span>][mask] %= mod;</span><br><span class="line">        cur_set.<span class="built_in">insert</span>(mask);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.<span class="built_in">assign</span>(cur_set.<span class="built_in">begin</span>(), cur_set.<span class="built_in">end</span>());<span class="comment">//set转vector</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> mask : cur)&#123;<span class="comment">//更新滚动数组</span></span><br><span class="line">      dp[<span class="number">1</span>][mask] = dp[<span class="number">0</span>][mask];</span><br><span class="line">      dp[<span class="number">0</span>][mask] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask : last)&#123;<span class="comment">//更新滚动数组</span></span><br><span class="line">      <span class="keyword">if</span> (cur_set.<span class="built_in">find</span>(mask) == cur_set.<span class="built_in">end</span>())&#123;</span><br><span class="line">        dp[<span class="number">1</span>][mask] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    last = cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> mask : last)&#123;</span><br><span class="line">    A = (A + dp[<span class="number">1</span>][mask]) % mod;<span class="comment">//这里是第一行的情况</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">fill</span>(dp[i].<span class="built_in">begin</span>(), dp[i].<span class="built_in">end</span>(), <span class="number">0</span>);<span class="comment">//初始化dp</span></span><br><span class="line">  &#125;</span><br><span class="line">  dp[<span class="number">1</span>][start_id] = <span class="number">1</span>;</span><br><span class="line">  last.<span class="built_in">clear</span>();</span><br><span class="line">  last.<span class="built_in">push_back</span>(start_id);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = k + <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cur.<span class="built_in">clear</span>();</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; cur_set;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; arr.<span class="built_in">size</span>(); mask++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> old_mask : last)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check</span>(arr[mask], arr[old_mask])) <span class="keyword">continue</span>;</span><br><span class="line">        dp[<span class="number">2</span>][mask] += dp[<span class="number">1</span>][old_mask];</span><br><span class="line">        dp[<span class="number">2</span>][mask] %= mod;</span><br><span class="line">        cur_set.<span class="built_in">insert</span>(mask);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.<span class="built_in">assign</span>(cur_set.<span class="built_in">begin</span>(), cur_set.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> mask : cur)&#123;</span><br><span class="line">      dp[<span class="number">1</span>][mask] = dp[<span class="number">2</span>][mask];</span><br><span class="line">      dp[<span class="number">2</span>][mask] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask : last)&#123;</span><br><span class="line">      <span class="keyword">if</span> (cur_set.<span class="built_in">find</span>(mask) == cur_set.<span class="built_in">end</span>())&#123;</span><br><span class="line">        dp[<span class="number">1</span>][mask] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    last = cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> mask : last)&#123;</span><br><span class="line">    B = (B + dp[<span class="number">1</span>][mask]) % mod;<span class="comment">//这里是第n行情况</span></span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; A * B % mod &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​看了别人的写法，发现滚动数组是不必要的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line">string s;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> ((a % <span class="number">3</span>) == (b % <span class="number">3</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    a /= <span class="number">3</span>;</span><br><span class="line">    b /= <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">str_to_int</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> c : s)&#123;</span><br><span class="line">    res = res * <span class="number">3</span> + (c - <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_dfs</span><span class="params">()</span></span>&#123;<span class="comment">//当然，题解是直接枚举3进制mask</span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">length</span>() == m)&#123;</span><br><span class="line">    <span class="type">int</span> mask = <span class="built_in">str_to_int</span>(s);</span><br><span class="line">    arr.<span class="built_in">push_back</span>(mask);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="type">char</span> c = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">      s.<span class="built_in">push_back</span>(c);</span><br><span class="line">      <span class="built_in">pre_dfs</span>();</span><br><span class="line">      s.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">back</span>() != c)&#123;</span><br><span class="line">        s.<span class="built_in">push_back</span>(c);</span><br><span class="line">        <span class="built_in">pre_dfs</span>();</span><br><span class="line">        s.<span class="built_in">pop_back</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">ll m1, m2, dp[<span class="number">10010</span>][<span class="number">300</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">  <span class="built_in">pre_dfs</span>();</span><br><span class="line">  <span class="type">int</span> sk, id = <span class="number">-1</span>;</span><br><span class="line">  s.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    s.<span class="built_in">push_back</span>(c);</span><br><span class="line">  &#125;</span><br><span class="line">  sk = <span class="built_in">str_to_int</span>(s);</span><br><span class="line">  <span class="comment">//用arr的索引代替mask</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] == sk)&#123;</span><br><span class="line">      id = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (id == <span class="number">-1</span>)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dp[k][id] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//可以看到这里的状态转移十分简洁</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; arr.<span class="built_in">size</span>(); mask++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> old_mask = <span class="number">0</span>; old_mask &lt; arr.<span class="built_in">size</span>(); old_mask++)&#123;</span><br><span class="line">        <span class="comment">//注意这里的mask是arr的索引，arr[mask]才是真正的掩码</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(arr[mask], arr[old_mask]))&#123;</span><br><span class="line">          dp[i][mask] = (dp[i][mask] + dp[i + <span class="number">1</span>][old_mask]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = k + <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; arr.<span class="built_in">size</span>(); mask++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> old_mask = <span class="number">0</span>; old_mask &lt; arr.<span class="built_in">size</span>(); old_mask++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(arr[mask], arr[old_mask]))&#123;</span><br><span class="line">          dp[i][mask] = (dp[i][mask] + dp[i - <span class="number">1</span>][old_mask]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; arr.<span class="built_in">size</span>(); mask++)&#123;</span><br><span class="line">    m1 = (m1 + dp[<span class="number">1</span>][mask]) % mod;</span><br><span class="line">    m2 = (m2 + dp[n][mask]) % mod;</span><br><span class="line">  &#125;;</span><br><span class="line">  cout &lt;&lt; m1 * m2 % mod &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/10/21/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91LittleKing/"/>
      <url>/2025/10/21/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91LittleKing/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在解决了关于象和车的趣味问题之后，Petya 决定他想学习下国际象棋。他开始学习规则，并发现游戏中最重要的棋子是<strong>王</strong>。</p><p>王可以移动到任何相邻的格子（这样的格子最多有八个）。因此，如果两个王位于相邻的格子，它们就处于<strong>互相攻击</strong>的状态。</p><p>当然，Petya 想知道的第一个问题是：在一个大小为 n × n 的棋盘上，有多少种方式可以放置 k 个王，使得它们之间<strong>没有两个王处于互相攻击的位置</strong>。请帮助他！</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入文件包含两个整数 n (1 ≤ n ≤ 10) 和 k (0 ≤ k ≤ n²)。</p><p><strong>输出</strong></p><p>输出一行，表示在给定大小的棋盘上放置给定数量的王，且没有任何两个王互相攻击的总方法数。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure><p>​二维状压dp，直接枚举所有情况是不可能的，但是可以分别对每一行枚举这一行的所有情况。可以做如下定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ll dp[maxn][<span class="number">1</span> &lt;&lt; maxn][maxn * <span class="number">10</span>];<span class="comment">//行，单行mask，到当前行位置放的国王个数</span></span><br><span class="line"><span class="type">int</span> s[<span class="number">1</span> &lt;&lt; maxn], cnt, sum[<span class="number">1</span> &lt;&lt; maxn];</span><br><span class="line"><span class="comment">//s记录了合法的单行mask，sum记录了合法mask中有几个国王，cnt是计数器</span></span><br></pre></td></tr></table></figure><p>​先处理单行情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)&#123;<span class="comment">//枚举所有mask</span></span><br><span class="line">    <span class="keyword">if</span> (!(i &amp; (i &gt;&gt; <span class="number">1</span>)))&#123;<span class="comment">//说明没有相邻的1挨着</span></span><br><span class="line">      s[cnt] = i;<span class="comment">//记录合法mask</span></span><br><span class="line">      sum[cnt++] = <span class="built_in">get_sum</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​然后在行间进行状态转移：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;<span class="comment">//检查上下两行之间是否合法</span></span><br><span class="line">  <span class="keyword">if</span> (a &amp; b) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//同一列有国王</span></span><br><span class="line">  <span class="keyword">if</span> ((a &gt;&gt; <span class="number">1</span>) &amp; b) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//左上方有国王</span></span><br><span class="line">  <span class="keyword">if</span> ((a &lt;&lt; <span class="number">1</span>) &amp; b) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//右上方有国王</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)<span class="comment">//第一行预处理了，从第二行开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; cnt; a++)<span class="comment">//枚举当前行mask</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; cnt; b++)<span class="comment">//枚举上一行mask</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> c = sum[a]; c &lt;= k; c++)<span class="comment">//枚举可能的国王数量</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(s[a], s[b]))<span class="comment">//如果上下两行之间合法</span></span><br><span class="line">          dp[i][a][c] += dp[i - <span class="number">1</span>][b][c - sum[a]];<span class="comment">//累加方案数</span></span><br></pre></td></tr></table></figure><p>​来看完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">11</span>;</span><br><span class="line">ll n, k;</span><br><span class="line">ll dp[maxn][<span class="number">1</span> &lt;&lt; maxn][maxn * <span class="number">10</span>];<span class="comment">//行，单行mask，到当前行位置放的国王个数</span></span><br><span class="line"><span class="type">int</span> s[<span class="number">1</span> &lt;&lt; maxn], cnt, sum[<span class="number">1</span> &lt;&lt; maxn];</span><br><span class="line"><span class="comment">//s记录了合法的单行mask，sum记录了合法mask中有几个国王，cnt是计数器</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//计算mask中有多少个1</span></span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">1</span>) cnt++;</span><br><span class="line">    x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)&#123;<span class="comment">//枚举所有mask</span></span><br><span class="line">    <span class="keyword">if</span> (!(i &amp; (i &gt;&gt; <span class="number">1</span>)))&#123;<span class="comment">//说明没有相邻的1挨着</span></span><br><span class="line">      s[cnt] = i;<span class="comment">//记录合法mask</span></span><br><span class="line">      sum[cnt++] = <span class="built_in">get_sum</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;<span class="comment">//检查上下两行之间是否合法</span></span><br><span class="line">  <span class="keyword">if</span> (a &amp; b) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//同一列有国王</span></span><br><span class="line">  <span class="keyword">if</span> ((a &gt;&gt; <span class="number">1</span>) &amp; b) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//左上方有国王</span></span><br><span class="line">  <span class="keyword">if</span> ((a &lt;&lt; <span class="number">1</span>) &amp; b) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//右上方有国王</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">  cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">pre</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)&#123;<span class="comment">//预处理第一行</span></span><br><span class="line">    dp[<span class="number">1</span>][i][sum[i]] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;<span class="comment">//第一行预处理了，从第二行开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; cnt; a++)&#123;<span class="comment">//枚举当前行mask</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; cnt; b++)&#123;<span class="comment">//枚举上一行mask</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = sum[a]; c &lt;= k; c++)&#123;<span class="comment">//枚举可能的国王数量</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">check</span>(s[a], s[b]))&#123;<span class="comment">//如果上下两行之间合法</span></span><br><span class="line">            dp[i][a][c] += dp[i - <span class="number">1</span>][b][c - sum[a]];<span class="comment">//累加方案数</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">    ans += dp[n][i][k];</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【数位dp】数字计数</title>
      <link href="/2025/10/20/%E3%80%90%E6%95%B0%E4%BD%8Ddp%E3%80%91%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0/"/>
      <url>/2025/10/20/%E3%80%90%E6%95%B0%E4%BD%8Ddp%E3%80%91%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p> 给定两个正整数 a 和 b，求在[a,b]中的所有整数中，每个数码(digit)各出现了多少次。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>中仅包含一行两个整数 a、b，含义如上所述。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>包含一行 10 个整数，分别表示 0-9 在[a,b]中出现了多少次。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 99</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 20 20 20 20 20 20 20 20 20</span><br></pre></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>30%的数据中，a&lt;&#x3D;b&lt;&#x3D;10^6^；<br>100%的数据中，a&lt;&#x3D;b&lt;&#x3D;10^12^。</p><p>​很多题解都是用递推做的，终于找到一篇dfs做的了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll a, b;</span><br><span class="line"><span class="comment">//dp[pos][当前位下目标dig的个数]</span></span><br><span class="line"><span class="comment">//在前pos位中出现sum个dig对后面的dfs没有影响，所以可以用dp[pos][sum]来记忆化</span></span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">20</span>], arr[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">bool</span> limited, <span class="type">bool</span> leader, <span class="type">int</span> dig, ll sum)</span></span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//所有位处理完毕，返回sum</span></span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">  <span class="comment">//记忆化</span></span><br><span class="line">  <span class="keyword">if</span> (!limited &amp;&amp; !leader &amp;&amp; dp[pos][sum] != <span class="number">-1</span>) <span class="keyword">return</span> dp[pos][sum];</span><br><span class="line">  <span class="type">int</span> up = limited ? arr[pos] : <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)&#123;</span><br><span class="line">    ans += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limited &amp;&amp; (i == up), leader &amp;&amp; (i == <span class="number">0</span>), dig, sum + (!(leader &amp;&amp; i == <span class="number">0</span>) &amp;&amp; (i == dig)));</span><br><span class="line">    <span class="comment">//当i == dig 并且没有前导0时sum++</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!limited &amp;&amp; !leader) dp[pos][sum] = ans;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x, ll d)</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span>) arr[pos++] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x)&#123;</span><br><span class="line">    arr[pos++] = x % <span class="number">10</span>;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dfs</span>(pos - <span class="number">1</span>, <span class="literal">true</span>, <span class="literal">true</span>, d, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>(b, i) - <span class="built_in">solve</span>(a - <span class="number">1</span>, i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数位dp】恨7不成妻</title>
      <link href="/2025/10/20/%E3%80%90%E6%95%B0%E4%BD%8Ddp%E3%80%91%E6%81%A87%E4%B8%8D%E6%88%90%E5%A6%BB/"/>
      <url>/2025/10/20/%E3%80%90%E6%95%B0%E4%BD%8Ddp%E3%80%91%E6%81%A87%E4%B8%8D%E6%88%90%E5%A6%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>单身!<br>依然单身！<br>吉哥依然单身！<br>DS级码农吉哥依然单身！<br>所以，他生平最恨情人节，不管是214还是77，他都讨厌！</p><p>吉哥观察了214和77这两个数，发现：<br>2 + 1 + 4 &#x3D; 7<br>7 + 7 &#x3D; 7 * 2<br>77 &#x3D; 7 * 11<br>最终，他发现原来这一切归根到底都是因为和7有关！所以，他现在甚至讨厌一切和7有关的数！</p><p>什么样的数和7有关呢？</p><p>如果一个整数符合下面3个条件之一，那么我们就说这个整数和7有关——<br>1、整数中某一位是7；<br>2、整数的每一位加起来的和是7的整数倍；<br>3、这个整数是7的整数倍；</p><p>现在问题来了：吉哥想知道在一定区间内和7无关的数字的平方和。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入数据的第一行是case数T(1 &lt;&#x3D; T &lt;&#x3D; 50)，然后接下来的T行表示T个case;每个case在一行内包含两个正整数L, R(1 &lt;&#x3D; L &lt;&#x3D; R &lt;&#x3D; 10^18^)。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>请计算[L,R]中和7无关的数字的平方和，并将结果对10^9^ + 7 求模后输出。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 9</span><br><span class="line">10 11</span><br><span class="line">17 17</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">236</span><br><span class="line">221</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>​和一般的数位dp不同，这题不是计算个数而是计算平方和。这里开一个结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  ll cnt, sum, sum2;<span class="comment">//分别表示符合条件的个数、总和、平方和</span></span><br><span class="line">&#125;dp[<span class="number">20</span>][<span class="number">7</span>][<span class="number">7</span>];<span class="comment">//当前数位、当前各数位上数之和模7，当前数模7</span></span><br></pre></td></tr></table></figure><p>​再来看转移方程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">node temp = node&#123;0, 0, 0&#125;;</span><br><span class="line">for (int i = 0; i &lt;= up; i++)&#123;</span><br><span class="line">  if (i == 7) continue;</span><br><span class="line">  node j = dfs(pos - 1, (sum + i ) % 7, (num * 10 + i) % 7, limited &amp;&amp; i == up);</span><br><span class="line">  ll B = i * pw[pos];</span><br><span class="line">  temp.cnt = (temp.cnt + j.cnt) % mod;</span><br><span class="line">  temp.sum = (temp.sum + j.cnt * B + j.sum) % mod;</span><br><span class="line">  temp.sum2 = (temp.sum2 + j.cnt * B % mod * B % mod + j.sum2 + 2 * j.sum % mod * B % mod) % mod;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​j是当前位的后缀，当前数字可以视为 i * pw[pos]（pw是预处理好的1^pos^） + 后缀，那么当前数字的平方就等于（前缀 + 后缀）^2^ &#x3D; 前缀^2^ + 2 * 前缀 * 后缀 + 后缀^2^。同时当前数有多少个后缀，当前前缀就要参与多少次计算，因此当前数的平方和为 cnt * 前缀^2^ + 2 * 前缀 * 后缀 + 后缀^2^。计算完当前数的平方和后再在sum2上累加。</p><p>​接下来展示完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll l, r;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">25</span>];</span><br><span class="line">ll pw[<span class="number">25</span>];<span class="comment">//记录pow(10, i) % mod;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  ll cnt, sum, sum2;<span class="comment">////分别表示符合条件的个数、总和、平方和</span></span><br><span class="line">&#125;dp[<span class="number">20</span>][<span class="number">7</span>][<span class="number">7</span>];<span class="comment">//当前数位、当前各数位上数之和模7，当前数模7</span></span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> sum, <span class="type">int</span> num, <span class="type">bool</span> limited)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) <span class="keyword">return</span> node&#123;sum &amp;&amp; num, <span class="number">0</span>, <span class="number">0</span>&#125;;<span class="comment">//表示有一个解</span></span><br><span class="line">  <span class="keyword">if</span> (!limited &amp;&amp; dp[pos][sum][num].cnt != <span class="number">-1</span>) <span class="keyword">return</span> dp[pos][sum][num];<span class="comment">//记忆化</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> up = limited ? arr[pos] : <span class="number">9</span>;</span><br><span class="line">  node temp = node&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">7</span>) <span class="keyword">continue</span>;<span class="comment">//不能含有7</span></span><br><span class="line">    <span class="comment">//j在这里表示后缀</span></span><br><span class="line">    node j = <span class="built_in">dfs</span>(pos - <span class="number">1</span>, (sum + i ) % <span class="number">7</span>, (num * <span class="number">10</span> + i) % <span class="number">7</span>, limited &amp;&amp; i == up);</span><br><span class="line">    <span class="comment">//B在这里表示前缀</span></span><br><span class="line">    ll B = i * pw[pos];</span><br><span class="line">    <span class="comment">//个数累加</span></span><br><span class="line">    temp.cnt = (temp.cnt + j.cnt) % mod;</span><br><span class="line">    <span class="comment">//和累加，注意这里的有多少个后缀，前缀就要加多少次，所以是j.cnt * B</span></span><br><span class="line">    temp.sum = (temp.sum + j.cnt * B + j.sum) % mod;</span><br><span class="line">    <span class="comment">//平方和累加，同理前缀要多次累加</span></span><br><span class="line">    temp.sum2 = (temp.sum2 + j.cnt * B % mod * B % mod + j.sum2 + <span class="number">2</span> * j.sum % mod * B % mod) % mod;    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!limited) dp[pos][sum][num] = temp;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_sum</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x)&#123;</span><br><span class="line">    arr[pos++] = x % <span class="number">10</span>;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span>) arr[pos++] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dfs</span>(pos - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>).sum2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">  pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i++)&#123;</span><br><span class="line">    pw[i] = pw[i - <span class="number">1</span>] * <span class="number">10</span> % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">get_sum</span>(r) - <span class="built_in">get_sum</span>(l - <span class="number">1</span>) + mod) % mod &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数位dp】Amount of Degrees</title>
      <link href="/2025/10/18/Amount%20of%20Degrees/"/>
      <url>/2025/10/18/Amount%20of%20Degrees/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>编写一个程序，计算在区间 [X, Y] 内，有多少个整数可以表示为 <strong>恰好 K 个不同的 B 的整数次幂之和</strong>。<br>设 X&#x3D;15, Y&#x3D;20, K&#x3D;2, B&#x3D;2。<br>在此示例中，有 3 个数可以表示为恰好两个不同的 2 的整数次幂之和：<br>17 &#x3D; 2^4^+2^0^,<br>18 &#x3D; 2^4^+2^1^,<br>20 &#x3D; 2^4^+2^2^.</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行包含两个整数 X 和 Y，用空格分隔（1 ≤ X ≤ Y ≤ 2³¹−1）。<br>接下来两行分别包含整数 K 和 B（1 ≤ K ≤ 20；2 ≤ B ≤ 10）。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出一个整数，表示在 [X, Y] 范围内，可以表示为恰好 K 个不同的 B 的整数次幂之和的数的个数。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">15 20</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>​B进制下的数位dp，由于K最大只去到20，因此可以用dfs来做。dp数组需要记录两个状态，一个是当前计算到哪一位了，另一个是还需要几位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll x, y, k, b;</span><br><span class="line"><span class="comment">//dp[当前是第i位][还要j个数字]</span></span><br><span class="line">ll dp[<span class="number">35</span>][<span class="number">25</span>], arr[<span class="number">35</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//初始化dp数组-1，表示没有计算过</span></span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll pos, ll k, <span class="type">bool</span> limit)</span></span>&#123;</span><br><span class="line">  <span class="comment">//k == 0表示k个数都已经取完了，该方案可行，总数加1</span></span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//pos &lt; 0 表示全部位都试过了，但该方案不可行</span></span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//当前状态之前算过，记忆化</span></span><br><span class="line">  <span class="keyword">if</span> (!limit &amp;&amp; dp[pos][k] != <span class="number">-1</span>) <span class="keyword">return</span> dp[pos][k];</span><br><span class="line">  <span class="comment">//计算当前位的上限</span></span><br><span class="line">  <span class="type">int</span> up = limit ? arr[pos] : <span class="number">9</span>;</span><br><span class="line">  ll temp = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//i要不取上限，要不在0，1之间取（表示不取或取）</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up &amp;&amp; i &lt;= <span class="number">1</span>; i++)&#123;</span><br><span class="line">    temp += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, k - i, limit &amp;&amp; i == up);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//非限制，存储dp</span></span><br><span class="line">  <span class="keyword">if</span> (!limit) dp[pos][k] = temp;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_num</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//统计每一位的数字到arr中，用于limit的判断</span></span><br><span class="line">  <span class="keyword">while</span>(x)&#123;</span><br><span class="line">    arr[pos++] = x % b;</span><br><span class="line">    x /= b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dfs</span>(pos - <span class="number">1</span>, k, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">  cin &gt;&gt; k &gt;&gt; b;</span><br><span class="line">  <span class="comment">//类前缀和计算</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">get_num</span>(y) - <span class="built_in">get_num</span>(x - <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树型dp】基环树上的dp</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%8E%AF%E6%A0%91%E4%B8%8A%E7%9A%84dp/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%8E%AF%E6%A0%91%E4%B8%8A%E7%9A%84dp/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Z国的骑士团是一个很有势力的组织，帮会中汇聚了来自各地的精英。他们劫富济贫，惩恶扬善，受到社会各界的赞扬。<br>最近发生了一件可怕的事情，邪恶的Y国发动了一场针对Z国的侵略战争。战火绵延五百里，在和平环境中安逸了数百年的Z国又怎能抵挡的住Y国的军队。于是人们把所有的希望都寄托在了骑士团的身上，就像期待有一个真龙天子的降生，带领正义打败邪恶。<br>骑士团是肯定具有打败邪恶势力的能力的，但是骑士们互相之间往往有一些矛盾。每个骑士都有且仅有一个自己最厌恶的骑士（当然不是他自己），他是绝对不会与自己最厌恶的人一同出征的。<br>战火绵延，人民生灵涂炭，组织起一个骑士军团加入战斗刻不容缓！国王交给了你一个艰巨的任务，从所有的骑士中选出一个骑士军团，使得军团内没有矛盾的两人（不存在一个骑士与他最痛恨的人一同被选入骑士军团的情况），并且，使得这支骑士军团最具有战斗力。<br>为了描述战斗力，我们将骑士按照1至N编号，给每名骑士一个战斗力的估计，一个军团的战斗力为所有骑士的战斗力总和。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行包含一个正整数N，描述骑士团的人数。<br>接下来N行，每行两个正整数，按顺序描述每一名骑士的战斗力和他最痛恨的骑士。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>应包含一行，包含一个整数，表示你所选出的骑士军团的战斗力。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">10 2</span><br><span class="line">20 3</span><br><span class="line">30 1</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>对于30%的测试数据，满足N ≤ 10；<br>对于60%的测试数据，满足N ≤ 100；<br>对于80%的测试数据，满足N ≤ 10 000。<br>对于100%的测试数据，满足N ≤ 1 000 000，每名骑士的战斗力都是不大于  1 000 000的正整数。</p><p>​正如标题所说，这题是到树型dp，不过这题的树是个基环树。将每个骑士视作子节点，将这个骑士讨厌的骑士视为他的父节点，由此建树，只有在根节点处才有可能成环。因此这题的解法和经典题目“没有上司的舞会”很像，只不过要加入对基环树的判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, fa[maxn], root;</span><br><span class="line">ll arr[maxn], dp[maxn][<span class="number">2</span>], ans = <span class="number">0</span>;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; adj[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DP</span><span class="params">(<span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">  vis[cur] = <span class="number">1</span>;</span><br><span class="line">  dp[cur][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//不选当前骑士</span></span><br><span class="line">  dp[cur][<span class="number">1</span>] = arr[cur];<span class="comment">//选当前骑士</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[cur])&#123;</span><br><span class="line">    <span class="keyword">if</span> (v != root)&#123;</span><br><span class="line">      <span class="built_in">DP</span>(v);</span><br><span class="line">      dp[cur][<span class="number">0</span>] += <span class="built_in">max</span>(dp[v][<span class="number">1</span>], dp[v][<span class="number">0</span>]);<span class="comment">//父亲不选，管他儿子选不选</span></span><br><span class="line">      dp[cur][<span class="number">1</span>] += dp[v][<span class="number">0</span>];<span class="comment">//父亲选了，儿子不能选</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      dp[v][<span class="number">1</span>] = -maxn;<span class="comment">//儿子为根，说明成基环树了</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_circle</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  vis[x] = <span class="number">1</span>;</span><br><span class="line">  root = x;</span><br><span class="line">  <span class="keyword">while</span>(!vis[fa[root]])&#123;<span class="comment">//找根节点</span></span><br><span class="line">    root = fa[root];</span><br><span class="line">    vis[root] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DP</span>(root);<span class="comment">//第一次DP：强制不选fa[root]（通过v != root条件）</span></span><br><span class="line">  ll temp = <span class="built_in">max</span>(dp[root][<span class="number">0</span>], dp[root][<span class="number">1</span>]);</span><br><span class="line">  vis[root] = <span class="number">1</span>;</span><br><span class="line">  root = fa[root];</span><br><span class="line">  <span class="built_in">DP</span>(root);<span class="comment">//第二次DP：强制不选原来的root</span></span><br><span class="line">  ans += <span class="built_in">max</span>(temp, <span class="built_in">max</span>(dp[root][<span class="number">0</span>], dp[root][<span class="number">1</span>]));</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="type">int</span> no;</span><br><span class="line">    cin &gt;&gt; no;</span><br><span class="line">    adj[no].<span class="built_in">push_back</span>(i);</span><br><span class="line">    fa[i] = no;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) <span class="built_in">find_circle</span>(i);<span class="comment">//可能为森林</span></span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面的代码在TK那过不了，64mb的内存限制我刚好卡在65mb，没办法只好不开vector了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, fa[maxn], root, arr[maxn];</span><br><span class="line">ll dp[maxn][<span class="number">2</span>], ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> head[maxn], nxt[maxn], to[maxn], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  nxt[++cnt] = head[u];</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">  to[cnt] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DP</span><span class="params">(<span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">  vis[cur] = <span class="number">1</span>;</span><br><span class="line">  dp[cur][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  dp[cur][<span class="number">1</span>] = arr[cur];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[cur]; i; i = nxt[i])&#123;</span><br><span class="line">    <span class="type">int</span> v = to[i];</span><br><span class="line">    <span class="keyword">if</span> (v != root)&#123;</span><br><span class="line">      <span class="built_in">DP</span>(v);</span><br><span class="line">      dp[cur][<span class="number">0</span>] += <span class="built_in">max</span>(dp[v][<span class="number">1</span>], dp[v][<span class="number">0</span>]);</span><br><span class="line">      dp[cur][<span class="number">1</span>] += dp[v][<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      dp[v][<span class="number">1</span>] = -maxn;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_circle</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">  root = x;</span><br><span class="line">  <span class="keyword">while</span>(!vis[fa[root]])&#123;</span><br><span class="line">    root = fa[root];</span><br><span class="line">    vis[root] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DP</span>(root);</span><br><span class="line">  ll temp = <span class="built_in">max</span>(dp[root][<span class="number">0</span>], dp[root][<span class="number">1</span>]);</span><br><span class="line">  vis[root] = <span class="number">1</span>;</span><br><span class="line">  root = fa[root];</span><br><span class="line">  <span class="built_in">DP</span>(root);</span><br><span class="line">  ans += <span class="built_in">max</span>(temp, <span class="built_in">max</span>(dp[root][<span class="number">0</span>], dp[root][<span class="number">1</span>]));</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="type">int</span> no;</span><br><span class="line">    cin &gt;&gt; no;</span><br><span class="line">    <span class="built_in">add_edge</span>(no, i);</span><br><span class="line">    fa[i] = no;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) <span class="built_in">find_circle</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【链表】单链表分段逆转</title>
      <link href="/2025/10/13/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%86%E6%AE%B5%E9%80%86%E8%BD%AC/"/>
      <url>/2025/10/13/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%86%E6%AE%B5%E9%80%86%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>​给定一个带头结点的单链表和一个整数<em>K</em>，要求你将链表中的每<em>K</em>个结点做一次逆转。例如给定单链表 1→2→3→4→5→6 和 <em>K</em>&#x3D;3，你需要将链表改造成 3→2→1→6→5→4；如果 <em>K</em>&#x3D;4，则应该得4→3→2→1→5→6。</p><h3 id="裁判测试程序样例："><a href="#裁判测试程序样例：" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data; <span class="comment">/* 存储结点数据 */</span></span><br><span class="line">    PtrToNode   Next; <span class="comment">/* 指向下一个结点的指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List; <span class="comment">/* 定义单链表类型 */</span></span><br><span class="line"></span><br><span class="line">List <span class="title function_">ReadInput</span><span class="params">()</span>; <span class="comment">/* 裁判实现，细节不表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">( List L )</span>; <span class="comment">/* 裁判实现，细节不表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">K_Reverse</span><span class="params">( List L, <span class="type">int</span> K )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List L;</span><br><span class="line">    <span class="type">int</span> K;</span><br><span class="line"></span><br><span class="line">    L = ReadInput();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;K);</span><br><span class="line">    K_Reverse( L, K );</span><br><span class="line">    PrintList( L );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 1 5 6</span><br></pre></td></tr></table></figure><p>​这道题也是个逆天题，不知道这个题能拿来干嘛用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">K_Reverse</span><span class="params">( List L, <span class="type">int</span> K )</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (K &lt;= <span class="number">1</span>) <span class="keyword">return</span> ;<span class="comment">//长度为1不用逆转</span></span><br><span class="line">  PtrToNode pre = L;</span><br><span class="line">  PtrToNode cur = L-&gt;Next;</span><br><span class="line">  <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;<span class="comment">//计数器</span></span><br><span class="line">    PtrToNode last = cur;<span class="comment">//逆转段的尾指针</span></span><br><span class="line">    <span class="keyword">while</span>(last != <span class="literal">NULL</span> &amp;&amp; cnt &lt; K)&#123;</span><br><span class="line">      last = last-&gt;Next;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="literal">NULL</span>) <span class="keyword">break</span>;<span class="comment">//尾指针超过了链表末尾，按题意这段不用逆转</span></span><br><span class="line">    PtrToNode prev = <span class="literal">NULL</span>;</span><br><span class="line">    PtrToNode next = <span class="literal">NULL</span>;</span><br><span class="line">    PtrToNode tail = cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; i++)&#123;</span><br><span class="line">      next = cur-&gt;Next;<span class="comment">//存储原本的next</span></span><br><span class="line">      cur-&gt;Next = prev;<span class="comment">//当前的节点的next变为前节点</span></span><br><span class="line">      prev = cur;<span class="comment">//前节点后移，i==k时prev代表当前段的尾节点</span></span><br><span class="line">      cur = next;<span class="comment">//当前节点后移，i==k时cur代表下一段的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;Next = prev;<span class="comment">//pre为上一段的尾节点，其next为当前段的尾节点</span></span><br><span class="line">    tail-&gt;Next = cur;<span class="comment">//tail为这一段的原头节点（逆转后是尾节点），其next是下一段的头节点</span></span><br><span class="line">    pre = tail;<span class="comment">//上一段尾节点更新为当前段的尾节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【链表】带头节点的链表操作集</title>
      <link href="/2025/10/13/%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C%E9%9B%86/"/>
      <url>/2025/10/13/%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>​带头节点的链表，意思就是头节点仅起内存地址索引作用，不实际存储数据。</p><p>​来看看作业题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR NULL</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span><span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="type">bool</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">PtrToLNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode Position;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br><span class="line"></span><br><span class="line">List <span class="title function_">MakeEmpty</span><span class="params">()</span>; </span><br><span class="line">Position <span class="title function_">Find</span><span class="params">( List L, ElementType X )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert</span><span class="params">( List L, ElementType X, Position P )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Delete</span><span class="params">( List L, Position P )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List L;</span><br><span class="line">    ElementType X;</span><br><span class="line">    Position P;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line"></span><br><span class="line">    L = MakeEmpty();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> ( N-- ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        flag = Insert(L, X, L-&gt;Next);</span><br><span class="line">        <span class="keyword">if</span> ( flag==<span class="literal">false</span> ) <span class="built_in">printf</span>(<span class="string">&quot;Wrong Answer\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> ( N-- ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        P = Find(L, X);</span><br><span class="line">        <span class="keyword">if</span> ( P == ERROR )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Finding Error: %d is not in.\n&quot;</span>, X);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = Delete(L, P);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is found and deleted.\n&quot;</span>, X);</span><br><span class="line">            <span class="keyword">if</span> ( flag==<span class="literal">false</span> )</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Wrong Answer.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flag = Insert(L, X, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( flag==<span class="literal">false</span> ) <span class="built_in">printf</span>(<span class="string">&quot;Wrong Answer\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is inserted as the last element.\n&quot;</span>, X);</span><br><span class="line">    P = (Position)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    flag = Insert(L, X, P);</span><br><span class="line">    <span class="keyword">if</span> ( flag==<span class="literal">true</span> ) <span class="built_in">printf</span>(<span class="string">&quot;Wrong Answer\n&quot;</span>);</span><br><span class="line">    flag = Delete(L, P);</span><br><span class="line">    <span class="keyword">if</span> ( flag==<span class="literal">true</span> ) <span class="built_in">printf</span>(<span class="string">&quot;Wrong Answer\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> ( P=L-&gt;Next; P; P = P-&gt;Next ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, P-&gt;Data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><p>​要我们完成下列函数的编写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List <span class="title function_">MakeEmpty</span><span class="params">()</span>; </span><br><span class="line">Position <span class="title function_">Find</span><span class="params">( List L, ElementType X )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert</span><span class="params">( List L, ElementType X, Position P )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Delete</span><span class="params">( List L, Position P )</span>;</span><br></pre></td></tr></table></figure><p>​具体的就看代码注释吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">List <span class="title function_">MakeEmpty</span><span class="params">()</span>&#123;<span class="comment">//init头节点</span></span><br><span class="line">    <span class="comment">//这个malloc写法也要记住，c++的new确实方便许多了</span></span><br><span class="line">    <span class="comment">//注意变量名前要加struct，这里List是LNode的指针</span></span><br><span class="line">    List head = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    head-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">Position <span class="title function_">Find</span><span class="params">( List L, ElementType X )</span>&#123;</span><br><span class="line">    <span class="comment">//头节点不存储数据，因此第一个元素是头节点的next</span></span><br><span class="line">    Position cur = L-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;Data == X) <span class="keyword">break</span>;</span><br><span class="line">        cur = cur-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert</span><span class="params">( List L, ElementType X, Position P )</span>&#123;</span><br><span class="line">    Position pre = L;</span><br><span class="line">    Position cur = L-&gt;Next;</span><br><span class="line">    PtrToLNode new_p = (PtrToLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span> &amp;&amp; P != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Wrong Position for Insertion\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur == P)&#123;</span><br><span class="line">            new_p-&gt;Data = X;</span><br><span class="line">            new_p-&gt;Next = P;</span><br><span class="line">            pre-&gt;Next = new_p;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Wrong Position for Insertion\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Delete</span><span class="params">( List L, Position P )</span>&#123;</span><br><span class="line">    Position pre = L;</span><br><span class="line">    Position cur = L-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == P)&#123;</span><br><span class="line">            pre-&gt;Next = cur-&gt;Next;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur -&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Wrong Position for Deletion\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模板】c语言快排</title>
      <link href="/2025/10/13/c%E8%AF%AD%E8%A8%80%E5%BF%AB%E6%8E%92/"/>
      <url>/2025/10/13/c%E8%AF%AD%E8%A8%80%E5%BF%AB%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<p>​c语言的快排不像c++一样有直接内置好的函数，排序函数需要自己写，以下为代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;<span class="comment">//void*是通用指针</span></span><br><span class="line">    ElementType fa = *(<span class="type">const</span> ElementType *)a;<span class="comment">//先用(const ElementType *)强制转换指针类型</span></span><br><span class="line">    ElementType fb = *(<span class="type">const</span> ElementType *)b;<span class="comment">//再用一个*解引用</span></span><br><span class="line">    <span class="keyword">if</span> (fa &lt; fb) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//降序排序，a比b小，a在b前</span></span><br><span class="line">    <span class="keyword">if</span> (fa &gt; fb) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ElementType <span class="title function_">Median</span><span class="params">( ElementType A[], <span class="type">int</span> N )</span> &#123;</span><br><span class="line">    ElementType B[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        B[i] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数组，数量， 当个元素大小，比较函数</span></span><br><span class="line">    qsort(B, N, <span class="keyword">sizeof</span>(ElementType), cmp);</span><br><span class="line">    <span class="type">int</span> mid = (N + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> B[mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这段代码实现了一个为数组排序并求中位数的功能，奇怪的是直接对A[]排序会wa，将A[]赋值给B[]就AC了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树型dp】旅游规划</title>
      <link href="/2025/10/13/%E3%80%90%E6%A0%91%E5%9E%8BDP%E3%80%91%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/"/>
      <url>/2025/10/13/%E3%80%90%E6%A0%91%E5%9E%8BDP%E3%80%91%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>W市的交通规划出现了重大问题，市政府下定决心在全市各大交通路口安排疏导员来疏导密集的车流。但由于人员不足，W市市长决定只在最需要安排人员的路口安排人员。<br>具体来说，W市的交通网络十分简单，由n个交叉路口和n−1条街道构成，交叉路口路口编号依次为0,1,⋯,n−1。任意一条街道连接两个交叉路口，且任意两个交叉路口间都存在一条路径互相连接。<br>经过长期调查，结果显示，如果一个交叉路口位于W市交通网最长路径上，那么这个路口必定拥挤不堪。所谓最长路径，定义为某条路径p&#x3D;(v1,v2,v3,vk)，路径经过的路口各不相同，且城市中不存在长度大于k的路径，因此最长路径可能不唯一。因此Ｗ市市长想知道哪些路口位于城市交通网的最长路径上。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行一个整数n；<br>之后n−1行每行两个整数u,v，表示u和v的路口间存在着一条街道。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出包括若干行，每行包括一个整数——某个位于最长路径上的路口编号。为了确保解唯一，请将所有最长路径上的路口编号按编号顺序由小到大依次输出。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">0 4</span><br><span class="line">0 6</span><br><span class="line">0 7</span><br><span class="line">1 3</span><br><span class="line">2 5</span><br><span class="line">4 8</span><br><span class="line">6 9</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>对于全部数据，1≤n≤2×10^5^。</p><p>​之前有一道题也是求树上最长路径的，不过只用求最长路径的长度所以只用跑一次dfs就行了。现在还要位于最长路径上的点并且最长路径可能还不止一条，因此要跑第二次dfs了。第一次dfs跑的是求该节点的子树中最长路和次长路，第二次dfs跑的时候求的是该节点向父节点方向的最长路，转移方程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = d1[v] + <span class="number">1</span>;<span class="comment">//当前子路长度</span></span><br><span class="line"><span class="keyword">if</span> (len &gt; d1[u])&#123;<span class="comment">//比最长路长</span></span><br><span class="line">  d2[u] = d1[u];</span><br><span class="line">  d1[u] = len;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (len &gt; d2[u])&#123;<span class="comment">//比次长路长</span></span><br><span class="line"> d2[u] = len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (d1[u] == d1[v] + <span class="number">1</span>)&#123;<span class="comment">//当前子路是父节点的最长路</span></span><br><span class="line">  up[v] = <span class="built_in">max</span>(up[u], d2[u]) + <span class="number">1</span>;<span class="comment">//取父节点的次长路作为子节点的父路</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  up[v] = <span class="built_in">max</span>(up[u], d1[u]) + <span class="number">1</span>;<span class="comment">//否则取父节点的最长路作为子节点的父路</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; </span><br><span class="line">vector &lt;<span class="type">int</span>&gt; adj[maxn];</span><br><span class="line"><span class="type">int</span> d1[maxn], d2[maxn], up[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  d1[u] = <span class="number">0</span>;</span><br><span class="line">  d2[u] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">    <span class="type">int</span> len = d1[v] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; d1[u])&#123;</span><br><span class="line">      d2[u] = d1[u];</span><br><span class="line">      d1[u] = len;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (len &gt; d2[u])&#123;</span><br><span class="line">      d2[u] = len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (d1[u] == d1[v] + <span class="number">1</span>)&#123;</span><br><span class="line">      up[v] = <span class="built_in">max</span>(up[u], d2[u]) + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      up[v] = <span class="built_in">max</span>(up[u], d1[u]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs2</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> max_road = <span class="number">0</span>;</span><br><span class="line">  vector &lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="type">int</span> temp = d1[i] + <span class="built_in">max</span>(d2[i], up[i]);</span><br><span class="line">    <span class="keyword">if</span> (temp &gt; max_road)&#123;</span><br><span class="line">      max_road = temp;</span><br><span class="line">      ans.<span class="built_in">clear</span>();</span><br><span class="line">      ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp == max_road)&#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x : ans)&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树型dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【分层图】Magical Girl Haze</title>
      <link href="/2025/10/12/%E5%88%86%E5%B1%82%E5%9B%BE/"/>
      <url>/2025/10/12/%E5%88%86%E5%B1%82%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><strong>题目描述</strong><br>某个国家有 N 座城市，以及 M 条从 u 到 v 的有向道路（1 ≤ u, v ≤ N）。每条道路都有一个距离 ci。<br>Haze 是一位魔法少女，住在城市 1，她可以选择不超过 K 条道路，将它们的距离变为 0。现在她想去城市 N，请你帮她计算从城市 1 到城市 N 的最小距离。</p><p><strong>输入</strong><br>第一行有一个整数 T（1 ≤ T ≤ 5），表示测试用例的数量。<br>对于每个测试用例：</p><ul><li>第一行有三个整数 N, M, K。</li><li>接下来的 M 行，每行有三个整数，描述一条道路：Ui, Vi, Ci。<br>u 和 v 之间可能存在多条道路。</li></ul><p>数据保证：</p><ul><li>N ≤ 100000</li><li>M ≤ 200000</li><li>K ≤ 10</li><li>0 ≤ c[i] ≤ 1e9</li><li>城市 1 和城市 N 之间至少存在一条路径。</li></ul><p><strong>输出</strong><br>对于每个测试用例，输出最小距离。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 6 1</span><br><span class="line">1 2 2</span><br><span class="line">1 3 4</span><br><span class="line">2 4 3</span><br><span class="line">3 4 1</span><br><span class="line">3 5 6</span><br><span class="line">4 5 2</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>​分层图的模板题，无需多言，上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dian</span>&#123;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  ll c;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> dian &amp;a, <span class="type">const</span> dian &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.c &gt; b.c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector &lt;dian&gt; adj[maxn];</span><br><span class="line">priority_queue &lt;dian, vector&lt;dian&gt;, cmp&gt; qe;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    adj[i].<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    ll c;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    adj[a].<span class="built_in">push_back</span>(&#123;b, c, <span class="number">0</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  qe.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">  vector &lt;vector&lt;ll&gt;&gt; <span class="built_in">dis</span>(n + <span class="number">1</span>, vector &lt;ll&gt; (k + <span class="number">1</span>, <span class="number">1e18</span>));</span><br><span class="line">  <span class="keyword">while</span>(!qe.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    dian temp = qe.<span class="built_in">top</span>();</span><br><span class="line">    qe.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (temp.c &gt; dis[temp.b][temp.k]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : adj[temp.b])&#123;</span><br><span class="line">      <span class="keyword">if</span> (temp.k == k)&#123;<span class="comment">//已经用了k次魔法，不能再用了</span></span><br><span class="line">        <span class="keyword">if</span> (temp.c + e.c &lt; dis[e.b][temp.k])&#123;</span><br><span class="line">          dis[e.b][temp.k] = temp.c + e.c;</span><br><span class="line">          qe.<span class="built_in">push</span>(&#123;e.b, temp.c + e.c, temp.k&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.k &lt; k)&#123;<span class="comment">//没到k次，就要分用魔法和不用魔法两种情况讨论</span></span><br><span class="line">        <span class="keyword">if</span> (temp.c + e.c &lt; dis[e.b][temp.k])&#123;</span><br><span class="line">          dis[e.b][temp.k] = temp.c + e.c;</span><br><span class="line">          qe.<span class="built_in">push</span>(&#123;e.b, temp.c + e.c, temp.k&#125;);        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.c &lt; dis[e.b][temp.k + <span class="number">1</span>])&#123;</span><br><span class="line">          dis[e.b][temp.k + <span class="number">1</span>] = temp.c;</span><br><span class="line">          qe.<span class="built_in">push</span>(&#123;e.b, temp.c, temp.k + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; dis[n][k] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【二分图】Magic Potion</title>
      <link href="/2025/10/12/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
      <url>/2025/10/12/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p><strong>题目描述</strong><br>在一个岛屿上住着 n 位英雄和 m 只怪物。这些天怪物变得非常凶残，因此英雄们决定消灭岛上的怪物。然而，第 i 位英雄只能杀死属于集合 Mi 中的一只怪物。<br>策略师 Joe 拥有 k 瓶魔法药水，每瓶药水可以增强一位英雄的能力，让他能够多杀死一只怪物。由于药水非常强大，每位英雄最多只能服用一瓶药水。<br>请帮助 Joe 找出，如果他采用最优策略，英雄们最多能杀死多少只怪物。</p><p><strong>输入</strong><br>第一行包含三个整数 n, m, k（1 ≤ n, m, k ≤ 500）—— 分别表示英雄的数量、怪物的数量和药水的瓶数。<br>接下来的 n 行中，每行首先包含一个整数 ti，表示集合 Mi 的大小，随后是 ti 个整数 Mi,j（1 ≤ j ≤ ti），表示第 i 位英雄能够杀死的怪物的索引（1 起始索引）（1 ≤ ti ≤ m，1 ≤ Mi,j ≤ m）。</p><p><strong>输出</strong><br>输出英雄们能够杀死的怪物的最大数量。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 5 2</span><br><span class="line">4 1 2 3 5</span><br><span class="line">2 2 5</span><br><span class="line">2 1 2</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>​一眼看出是二分图匹配，用匈牙利算法跑了半天没跑出正确答案，原因就在于这个魔法药水。后来发现用网络流做更加简单：首先确立源点1，然后是普通杀怪点2，(1, 2)的容量是n，表示n个英雄各自可以杀一只怪；接着建立嗑药杀怪点3，(1, 3)的容量是k，表示还有至多k个英雄能各自再杀一只怪。最终将2、3与各个英雄相连，英雄与各自能杀的怪相连，所有怪与汇点相连，并将这三步中所有边的容量设置为1，建图就大功告成了。这样跑一遍ISAP，答案就出来了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>, head[N];</span><br><span class="line"><span class="type">int</span> n, m, k, maxflow;</span><br><span class="line"><span class="type">int</span> dep[N], gap[N], cur[N];</span><br><span class="line"><span class="type">int</span> s,t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="type">int</span> v, next, val;</span><br><span class="line">&#125;node[<span class="number">10</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  node[++cnt].v = v;</span><br><span class="line">  node[cnt].val = val;</span><br><span class="line">  node[cnt].next = head[u];</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = s; i &lt;= t; i++)&#123;</span><br><span class="line">    dep[i] = <span class="number">-1</span>;</span><br><span class="line">    gap[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dep[t] = <span class="number">0</span>;</span><br><span class="line">  gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  queue &lt;<span class="type">int</span>&gt; qe;</span><br><span class="line">  qe.<span class="built_in">push</span>(t);</span><br><span class="line">  <span class="keyword">while</span>(!qe.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u = qe.<span class="built_in">front</span>();</span><br><span class="line">    qe.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = node[i].next)&#123;</span><br><span class="line">      <span class="type">int</span> v = node[i].v;</span><br><span class="line">      <span class="keyword">if</span> (dep[v] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">      qe.<span class="built_in">push</span>(v);</span><br><span class="line">      dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">      gap[dep[v]]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> flow)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (u == t)&#123;</span><br><span class="line">    maxflow += flow;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> used = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> &amp;i = cur[u]; i; i = node[i].next)&#123;</span><br><span class="line">    <span class="type">int</span> v = node[i].v;</span><br><span class="line">    <span class="keyword">if</span> (node[i].val &amp;&amp; dep[v] + <span class="number">1</span> == dep[u])&#123;</span><br><span class="line">      <span class="type">int</span> mi = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(flow - used, node[i].val));</span><br><span class="line">      <span class="keyword">if</span> (mi)&#123;</span><br><span class="line">        node[i].val -= mi;</span><br><span class="line">        node[i ^ <span class="number">1</span>].val += mi;</span><br><span class="line">        used += mi;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (used == flow) <span class="keyword">return</span> used;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  gap[dep[u]]--;</span><br><span class="line">  <span class="keyword">if</span> (gap[dep[u]] == <span class="number">0</span>) dep[s] = t + <span class="number">1</span>;</span><br><span class="line">  dep[u]++;</span><br><span class="line">  gap[dep[u]]++;</span><br><span class="line">  <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ISAP</span><span class="params">()</span></span>&#123;</span><br><span class="line">  maxflow = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="keyword">while</span>(dep[s] &lt; t + <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s; i &lt;= t + <span class="number">1</span>; i++) cur[i] = head[i];</span><br><span class="line">    <span class="built_in">dfs</span>(s, inf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">  <span class="built_in">addedge</span>(<span class="number">1</span>, <span class="number">2</span>, n);</span><br><span class="line">  <span class="built_in">addedge</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">addedge</span>(<span class="number">1</span>, <span class="number">3</span>, k);</span><br><span class="line">  <span class="built_in">addedge</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  s = <span class="number">1</span>, t = <span class="number">4</span> + n + m;</span><br><span class="line">  <span class="type">int</span> hero_start = <span class="number">4</span>, hero_end = <span class="number">3</span> + n, mon_end = <span class="number">3</span> + m + n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = hero_start; i &lt;= hero_end; i++)&#123;</span><br><span class="line">    <span class="built_in">addedge</span>(<span class="number">2</span>, i, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">addedge</span>(i, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">addedge</span>(<span class="number">3</span>, i, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">addedge</span>(i, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    <span class="keyword">while</span>(num--)&#123;</span><br><span class="line">      <span class="type">int</span> x;</span><br><span class="line">      cin &gt;&gt; x;</span><br><span class="line">      <span class="built_in">addedge</span>(i, hero_end + x, <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">addedge</span>(hero_end + x, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = hero_end + <span class="number">1</span>; i &lt;= mon_end; i++)&#123;</span><br><span class="line">    <span class="built_in">addedge</span>(i, t, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">addedge</span>(t, i, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">ISAP</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 二分图 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树型dp】数字转换</title>
      <link href="/2025/10/12/study-dp-i/"/>
      <url>/2025/10/12/study-dp-i/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>如果一个数x的约数和y（不包括他本身）比他本身小，那么x可以变成y，y也可以变成x。例如4可以变为3，1可以变为7。限定所有数字变换在不超过n的正整数范围内进行，求不断进行数字变换且不出现重复数字的最多变换步数。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入一个正整数n。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出不断进行数字变换且不出现重复数字的最多变换步数。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>一种方案为 4→3→1→7<br>对于100%的数据，1≤n≤50000。</p><p>​这一题初看怎么也想不到会是dp，不过在看到n的数字给的比较小后就能想到建图。建图后可以发现得到了一个森林，一开始想跑两遍dfs找最长路径，但后来看了题解发现用树型dp可以只用跑一次dfs。</p><p>​让我们令du[]表示从该节点出发的最长路，dv[]表示次长路，那么转移方程是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">  <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="built_in">dfs</span>(v, u);</span><br><span class="line">  <span class="keyword">if</span> (du[v] &gt; du[u] - <span class="number">1</span>)&#123;<span class="comment">//比最长路要大</span></span><br><span class="line">    dv[u] = du[u] - <span class="number">1</span>;<span class="comment">//原最长路变次长路</span></span><br><span class="line">    du[u] = du[v] + <span class="number">1</span>;<span class="comment">//新的最长路为du[v]加上(u, v)这一条边</span></span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (du[v] &gt; dv[u])&#123;<span class="comment">//比次长路要大</span></span><br><span class="line">    dv[u] = du[v];<span class="comment">//更新次长路</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​下面是完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; adj[<span class="number">50010</span>];</span><br><span class="line"><span class="type">int</span> du[<span class="number">50010</span>], dv[<span class="number">50010</span>], ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">50010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> j = x / i;</span><br><span class="line">        <span class="keyword">if</span> (i != j) sum += i + j;</span><br><span class="line">        <span class="keyword">else</span> sum += i;  </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= <span class="number">1</span> &amp;&amp; sum &lt;= n &amp;&amp; sum &lt; x)&#123;</span><br><span class="line">      adj[x].<span class="built_in">push_back</span>(sum);</span><br><span class="line">      adj[sum].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  vis[u] = <span class="number">1</span>;</span><br><span class="line">  du[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    <span class="keyword">if</span> (du[v] &gt; du[u] - <span class="number">1</span>)&#123;</span><br><span class="line">      dv[u] = du[u] - <span class="number">1</span>;</span><br><span class="line">      du[u] = du[v] + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (du[v] &gt; dv[u])&#123;</span><br><span class="line">      dv[u] = du[v];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = <span class="built_in">max</span>(ans, du[u] + dv[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios:: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="built_in">pre</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) <span class="built_in">dfs</span>(i, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans - <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树型dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【区间dp】凸多边形的划分</title>
      <link href="/2025/10/11/study-dp-c/"/>
      <url>/2025/10/11/study-dp-c/</url>
      
        <content type="html"><![CDATA[<p><strong>题目描述</strong><br>给定一个具有N个顶点的凸多边形，将顶点从1至N标号，每个顶点的权值都是一个正整数。将这个凸多边形划分成N−2个互不相交的三角形，试求这些三角形顶点的权值乘积和至少为多少。<br><strong>输入</strong><br>输入第一行为顶点数N（N≤50）<br>第二行依次为顶点1至顶点N的权值。<br><strong>输出</strong><br>输出仅一行，为这些三角形顶点的权值乘积和的最小值。<br><strong>样例输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">121 122 123 245 231</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12214884</span><br></pre></td></tr></table></figure><p>​这道题目看似几何问题，实际上居然是一道区间dp。大体思路不难：先选取两个顶点i，j连成一条边，然后在区间[i，j]内找到第三点k作为分割点，转移方程为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k][j] + (i128)w[i] * w[k] * w[j]);</span><br></pre></td></tr></table></figure><p>显而易见在初始化时相邻的两个点连成的边应该初始化为0，其余边初始化为inf。</p><p>还有一点要注意，TK给的数据数值特别大，要开int128或者高精度！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span> &lt;&lt; (ostream &amp;os, i128 n)&#123;</span><br><span class="line">  string s;</span><br><span class="line">  <span class="keyword">while</span>(n)&#123;</span><br><span class="line">    s += <span class="string">&#x27;0&#x27;</span> + n % <span class="number">10</span>;</span><br><span class="line">    n /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> i128 inf = <span class="number">1e30</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll w[<span class="number">110</span>];</span><br><span class="line">i128 dp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios:: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; w[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (j - i &lt; <span class="number">2</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> dp[i][j] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">3</span>; len &lt;= n; len++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)&#123;</span><br><span class="line">      <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)&#123;</span><br><span class="line">        dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k][j] + (i128)w[i] * w[k] * w[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
