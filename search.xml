<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>链式队列</title>
      <link href="/2025/10/27/%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97/"/>
      <url>/2025/10/27/%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> * PtrToNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123; <span class="comment">//元素节点</span></span><br><span class="line">  ElementType Data;</span><br><span class="line">  PtrToNode Next;<span class="comment">//链式存储</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span> *PtrToQNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QNode</span>&#123;</span><br><span class="line">  Position Front, Rear;<span class="comment">//头节点和尾节点</span></span><br><span class="line">  <span class="type">int</span> Maxsize, CurSize;<span class="comment">//记录大小</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToQNode Queue;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue <span class="title">createQueue</span><span class="params">(<span class="type">int</span> MaxSize)</span></span>&#123;</span><br><span class="line">  Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">  Q-&gt;Front = Q-&gt;Rear = <span class="literal">NULL</span>;</span><br><span class="line">  Q-&gt;Maxsize = MaxSize;</span><br><span class="line">  Q-&gt;CurSize = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isfull</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Q-&gt;CurSize == Q-&gt;Maxsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;Front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Queue Q, ElementType X)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isfull</span>(Q))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FULL\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Position new_p = (Position)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">  new_p-&gt;Data = X;</span><br><span class="line">  new_p-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isempty</span>(Q))&#123;</span><br><span class="line">    Q-&gt;Front = Q-&gt;Rear = new_p;<span class="comment">//如果Q为空，头尾元素均为它</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Q-&gt;Rear-&gt;Next = new_p;<span class="comment">//否则插入到尾节点后</span></span><br><span class="line">    Q-&gt;Rear = new_p;<span class="comment">//更新尾节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  Q-&gt;CurSize++;<span class="comment">//数量++</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">pop</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">  Position frontcell;</span><br><span class="line">  ElementType element;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isempty</span>(Q))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;EMPTY\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  frontcell = Q-&gt;Front;</span><br><span class="line">  <span class="keyword">if</span> (Q-&gt;Front == Q-&gt;Rear)&#123;<span class="comment">//如果只有一个元素</span></span><br><span class="line">    Q-&gt;Front = Q-&gt;Rear = <span class="literal">NULL</span>;<span class="comment">//头尾都设置为full</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Q-&gt;Front = Q-&gt;Front-&gt;Next;<span class="comment">//否则只删除头节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  element = frontcell-&gt;Data;</span><br><span class="line">  <span class="built_in">free</span>(frontcell);<span class="comment">//释放空间</span></span><br><span class="line">  Q-&gt;CurSize--;<span class="comment">//减少数量</span></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 特殊线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/10/27/2025-10-27/"/>
      <url>/2025/10/27/2025-10-27/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/10/27/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
      <url>/2025/10/27/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QNode</span> * PtrToQNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QNode</span>&#123;</span><br><span class="line">  ElementType * Data;</span><br><span class="line">  Position Front, Rear;</span><br><span class="line">  <span class="type">int</span> MaxSize;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToQNode Queue;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue <span class="title">CreateQueue</span><span class="params">(<span class="type">int</span> MaxSize)</span></span>&#123;</span><br><span class="line">  Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">  Q-&gt;Data = (ElementType *)<span class="built_in">malloc</span>(MaxSize * <span class="built_in">sizeof</span>(ElementType));</span><br><span class="line">  Q-&gt;Front = Q-&gt;Rear = <span class="number">0</span>;</span><br><span class="line">  Q-&gt;MaxSize = MaxSize;</span><br><span class="line">  <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isfull</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((Q-&gt;Rear + <span class="number">1</span>) % Q-&gt;MaxSize == Q-&gt;Front);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Queue Q, ElementType X)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isfull</span>(Q))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FULL\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Q-&gt;Rear = (Q-&gt;Rear + <span class="number">1</span>) % Q-&gt;MaxSize;</span><br><span class="line">  Q-&gt;Data[Q-&gt;Rear] = X;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Q-&gt;Front == Q-&gt;Rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">pop</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isempty</span>(Q))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;EMPTY\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> element = Q-&gt;Data[Q-&gt;Front];</span><br><span class="line">  Q-&gt;Front = (Q-&gt;Front + <span class="number">1</span>) % Q-&gt;MaxSize;</span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 特殊线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带头节点的链栈</title>
      <link href="/2025/10/27/%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E6%A0%88/"/>
      <url>/2025/10/27/%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SNode</span> *PtrToSNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SNode</span>&#123;</span><br><span class="line">  ElementType Data;<span class="comment">//元素</span></span><br><span class="line">  PtrToSNode Next;<span class="comment">//下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToSNode Stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Stack S, ElementType X)</span></span>&#123;<span class="comment">//在头节点S与S-&gt;Next之间插入新元素</span></span><br><span class="line">  PtrToSNode new_p = (PtrToSNode)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> SNode));</span><br><span class="line">  new_p-&gt;Data = X;</span><br><span class="line">  new_p-&gt;Next = S-&gt;Next;</span><br><span class="line">  S-&gt;Next = new_p;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">pop</span><span class="params">(Stack S)</span></span>&#123;<span class="comment">//删除S-&gt;Next</span></span><br><span class="line">  <span class="keyword">if</span> (S-&gt;Next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;EMPTY\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  PtrToSNode cur_top = S-&gt;Next;</span><br><span class="line">  <span class="type">int</span> element = cur_top-&gt;Data;</span><br><span class="line">  S-&gt;Next = cur_top-&gt;Next;</span><br><span class="line">  <span class="built_in">free</span>(cur_top);<span class="comment">//释放空间</span></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 特殊线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序栈</title>
      <link href="/2025/10/27/%E9%A1%BA%E5%BA%8F%E6%A0%88/"/>
      <url>/2025/10/27/%E9%A1%BA%E5%BA%8F%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SNode</span> * PtrToSNode;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SNode</span>&#123;</span><br><span class="line">  ElementType * Data;<span class="comment">//动态数组</span></span><br><span class="line">  Position Top;<span class="comment">//栈顶</span></span><br><span class="line">  <span class="type">int</span> MaxSize;<span class="comment">//最大容量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToSNode Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">(<span class="type">int</span> MaxSize)</span></span>&#123;</span><br><span class="line">  Stack S = (Stack)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> SNode));<span class="comment">//初始化一个栈</span></span><br><span class="line">  S-&gt;Data = (ElementType *)<span class="built_in">malloc</span>(MaxSize * <span class="built_in">sizeof</span>(ElementType));<span class="comment">//给动态数组初始化大小</span></span><br><span class="line">  S-&gt;Top = <span class="number">-1</span>;<span class="comment">//栈顶初始化为1，代表没有元素</span></span><br><span class="line">  S-&gt;MaxSize = MaxSize;<span class="comment">//赋值栈的容量</span></span><br><span class="line">  <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isfull</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> S-&gt;Top == S-&gt;MaxSize - <span class="number">1</span>;<span class="comment">//数组满了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Stack S, ElementType X)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isfull</span>(S))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FULL!!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  S-&gt;Data[++S-&gt;Top] = X;<span class="comment">//先加top再赋值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> S-&gt;Top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">pos</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isempty</span>(S))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;EMPTY!!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> S-&gt;Data[S-&gt;Top--];<span class="comment">//先吐出元素再减top</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 特殊线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在一个数组中实现两个堆栈</title>
      <link href="/2025/10/27/%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%A0%86%E6%A0%88/"/>
      <url>/2025/10/27/%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%A0%86%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>本题要求在一个数组中实现两个堆栈。</p><h3 id="函数接口定义："><a href="#函数接口定义：" class="headerlink" title="函数接口定义："></a>函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">( <span class="type">int</span> MaxSize )</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">( Stack S, ElementType X, <span class="type">int</span> Tag )</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">( Stack S, <span class="type">int</span> Tag )</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>Tag</code>是堆栈编号，取1或2；<code>MaxSize</code>堆栈数组的规模；<code>Stack</code>结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Position;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SNode</span> &#123;</span><br><span class="line">    ElementType *Data;</span><br><span class="line">    Position Top1, Top2;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SNode</span> *Stack;</span><br></pre></td></tr></table></figure><p>注意：如果堆栈已满，<code>Push</code>函数必须输出“Stack Full”并且返回false；如果某堆栈是空的，则<code>Pop</code>函数必须输出“Stack Tag Empty”（其中Tag是该堆栈的编号），并且返回ERROR。</p><h3 id="裁判测试程序样例："><a href="#裁判测试程序样例：" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 1e8</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; push, pop, end &#125; Operation;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; <span class="literal">false</span>, <span class="literal">true</span> &#125; <span class="type">bool</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Position;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SNode</span> &#123;</span><br><span class="line">    ElementType *Data;</span><br><span class="line">    Position Top1, Top2;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SNode</span> *Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">( <span class="type">int</span> MaxSize )</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">( Stack S, ElementType X, <span class="type">int</span> Tag )</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">( Stack S, <span class="type">int</span> Tag )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Operation <span class="title">GetOp</span><span class="params">()</span></span>;  <span class="comment">/* details omitted */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintStack</span><span class="params">( Stack S, <span class="type">int</span> Tag )</span></span>; <span class="comment">/* details omitted */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N, Tag, X;</span><br><span class="line">    Stack S;</span><br><span class="line">    <span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    S = <span class="built_in">CreateStack</span>(N);</span><br><span class="line">    <span class="keyword">while</span> ( !done ) &#123;</span><br><span class="line">        <span class="keyword">switch</span>( <span class="built_in">GetOp</span>() ) &#123;</span><br><span class="line">        <span class="keyword">case</span> push: </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;Tag, &amp;X);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">Push</span>(S, X, Tag)) <span class="built_in">printf</span>(<span class="string">&quot;Stack %d is Full!\n&quot;</span>, Tag);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> pop:</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Tag);</span><br><span class="line">            X = <span class="built_in">Pop</span>(S, Tag);</span><br><span class="line">            <span class="keyword">if</span> ( X==ERROR ) <span class="built_in">printf</span>(<span class="string">&quot;Stack %d is Empty!\n&quot;</span>, Tag);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> end:</span><br><span class="line">            <span class="built_in">PrintStack</span>(S, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">PrintStack</span>(S, <span class="number">2</span>);</span><br><span class="line">            done = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">Push 1 1</span><br><span class="line">Pop 2</span><br><span class="line">Push 2 11</span><br><span class="line">Push 1 2</span><br><span class="line">Push 2 12</span><br><span class="line">Pop 1</span><br><span class="line">Push 2 13</span><br><span class="line">Push 2 14</span><br><span class="line">Push 1 3</span><br><span class="line">Pop 2</span><br><span class="line">End</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack 2 Empty</span><br><span class="line">Stack 2 is Empty!</span><br><span class="line">Stack Full</span><br><span class="line">Stack 1 is Full!</span><br><span class="line">Pop from Stack 1: 1</span><br><span class="line">Pop from Stack 2: 13 12 11</span><br></pre></td></tr></table></figure><p>代码长度限制</p><p>16 KB</p><p>时间限制</p><p>400 ms</p><p>内存限制</p><p>64 MB</p><p>​也是个脑抽的题目，为什么我非要在一个数组里定义两个堆栈？而且在一个数组里定义两个堆栈，又不给我内存空间使用的标准，那我怎么定义？要我猜吗？</p><p>​别说，真靠猜，下面是完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">( <span class="type">int</span> MaxSize )</span></span>&#123;</span><br><span class="line">  Stack head = (Stack)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> SNode));<span class="comment">//定义头节点</span></span><br><span class="line">  head-&gt;Data = (ElementType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElementType) * MaxSize);<span class="comment">//开数组</span></span><br><span class="line">  head-&gt;MaxSize = MaxSize;</span><br><span class="line">  head-&gt;Top1 = <span class="number">-1</span>;<span class="comment">//一号堆栈从0开始</span></span><br><span class="line">  head-&gt;Top2 = MaxSize; <span class="comment">//二号堆栈从末尾开始</span></span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">( Stack S,ElementType X, <span class="type">int</span> Tag )</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (S-&gt;Top1 + <span class="number">1</span> == S-&gt;Top2)&#123;<span class="comment">//两个堆栈相遇，表示数组满了</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack Full\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Tag == <span class="number">1</span>)&#123;<span class="comment">//tag1，一号栈添加元素</span></span><br><span class="line">    S-&gt;Data[++S-&gt;Top1] = X;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;<span class="comment">//tag2，二号栈添加元素</span></span><br><span class="line">    S-&gt;Data[--S-&gt;Top2] = X;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">( Stack S, <span class="type">int</span> Tag )</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Tag == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;Top1 == <span class="number">-1</span>)&#123;<span class="comment">//一号堆栈为空</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Stack %d Empty\n&quot;</span>, Tag);</span><br><span class="line">      <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;Data[S-&gt;Top1--];<span class="comment">//指针前移</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;Top2 == S-&gt;MaxSize)&#123;<span class="comment">//二号堆栈为空</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Stack %d Empty\n&quot;</span>, Tag);</span><br><span class="line">      <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;Data[S-&gt;Top2++];<span class="comment">//指针后移</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树】完全二叉树后序变层序</title>
      <link href="/2025/10/23/%E3%80%90%E6%A0%91%E3%80%91%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E5%8F%98%E5%B1%82%E5%BA%8F/"/>
      <url>/2025/10/23/%E3%80%90%E6%A0%91%E3%80%91%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E5%8F%98%E5%B1%82%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是<strong>完美二叉树</strong>。对于深度为 <em>D</em> 的，有 <em>N</em> 个结点的二叉树，若其结点对应于相同深度完美二叉树的层序遍历的前 <em>N</em> 个结点，这样的树就是<strong>完全二叉树</strong>。</p><p>给定一棵完全二叉树的后序遍历，请你给出这棵树的层序遍历结果。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第一行中给出正整数 <em>N</em>（≤30），即树中结点个数。第二行给出后序遍历序列，为 <em>N</em> 个不超过 100 的正整数。同一行中所有数字都以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出该树的层序遍历序列。所有数字都以 1 个空格分隔，行首尾不得有多余空格。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">91 71 2 34 10 15 55 18</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18 34 55 71 2 10 15 91</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, w[<span class="number">10010</span>],ans[<span class="number">10010</span>], id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt; n) <span class="keyword">return</span> ;</span><br><span class="line">  <span class="built_in">dfs</span>(pos &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">dfs</span>((pos &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">  ans[pos] = w[++id];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; w[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;cout &lt;&lt; ans[n];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【状压dp】猛兽动物园</title>
      <link href="/2025/10/22/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91%E7%8C%9B%E5%85%BD%E5%8A%A8%E7%89%A9%E5%9B%AD/"/>
      <url>/2025/10/22/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91%E7%8C%9B%E5%85%BD%E5%8A%A8%E7%89%A9%E5%9B%AD/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>张琪曼惊喜道：“哇，抓到这么多猛兽，把它们都关到动物园吧。不过这个牙齿锋利的狮子好可怕啊。”</p><p>楚继光：“我倒不觉得，看那头鬃毛多可爱啊，不过这大猩猩太难看了。”</p><p>现在这些猛兽都被关在魔法世界的圆形动物园，圆形动物园包含一大圈围栏，每个围栏里有一种动物，有K个小朋友站在大围栏圈的外面，可以看到连续的5个围栏。每个小朋友有喜欢和害怕的动物。当下面两处情况之一发生时，小朋友就会高兴：</p><p>至少有一个他害怕的动物被移走；</p><p>至少有一个他喜欢的动物没被移走。</p><p>你可以选择将一些动物从围栏中移走以使得小朋友不会害怕。但你不能移走所有的动物，否则小朋友们就没有动物可看了。</p><p>例如，考虑图中的小伙伴和动物：<br><img src="http://180.201.136.244/upload/image/20160707/20160707112504_65750.png" alt="img"><img src="http://180.201.136.244/upload/image/20160707/20160707112514_74938.png" alt="img"><br>假如你将围栏4和12的动物移走，Alex和Ka-Shu将很高兴，因为至少有一个他们害怕的动物被移走了。这也会使Chaitanya高兴，因为他喜欢的围栏6和8中的动物都保留了。但是，Polly和Hwan将不高兴，因为他们看不到任何他们喜欢的动物，而他们害怕的动物都还在。这种安排方式使得三个小朋友高兴。</p><p>现在，换一种方法，如果你将围栏4和6中的动物移走，Alex和Polly将很高兴，因为他们害怕的动物被移走了。Chaitanya也会高兴，虽然他喜欢的动物6被移走了，他仍可以看到围栏8里面他喜欢的动物。同样的Hwan也会因可以看到自己喜欢的动物12而高兴。唯一不高兴的只有Ka-Shu。</p><p>如果你只移走围栏13中的动物，Ka-Shu将高兴，因为有一个他害怕的动物被移走了，Alex， Polly，Chaitanya和Hwan也会高兴，因为他们都可以看到至少一个他们喜欢的动物。所以有5个小朋友会高兴。这种方法使得最多的小朋友高兴。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含两个整数N，C，用空格分隔。N是围栏数(1≤N≤10 000)，C是小朋友的个数(1≤C≤50 000)。围栏按照顺时针的方向编号为1，2，3，…，N。</p><p>接下来的C行，每行描述一个小朋友，描述下面的形式给出： E F L X1 X2 …XF Y1 Y2 … YL 其中：</p><p>E表示小朋友可以看到的第一个围栏的编号(1≤E≤N)，也就是说，小朋友可以看到的围栏为E，E+1，E+2，E+3，E+4。注意，如果编号超过N将继续从1开始算。如：当N&#x3D;14，E&#x3D;13时，小朋友可以看到的围栏为13，14，1，2和3。</p><p>F表示小朋友害怕的动物数。L表示小朋友喜欢的动物数。 围栏X1，X2，…， XF中包含小朋友害怕的动物。 围栏Y1，Y2，…， YL中包含该小朋友喜欢的动物。</p><p>X1， X2，…，XF， Y1， Y2，…YL是两两不同的数，而且所表示的围栏都是小朋友可以看到的。</p><p>小朋友已经按照他们可以看到的第一个围栏的编号从小到大的顺序排好了(这样最小的E对应的小朋友排在第一个，最大的E对应的小朋友排在最后一个)。注意可能有多于一个小朋友对应的E是相同的。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>仅输出一个数，表示最多可以让多少个小朋友高兴。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 10</span><br><span class="line">1 1 1 3 2</span><br><span class="line">2 1 0 4</span><br><span class="line">3 1 1 5 6</span><br><span class="line">4 1 1 7 6</span><br><span class="line">5 1 0 6</span><br><span class="line">6 1 2 9 8 10</span><br><span class="line">7 1 0 10</span><br><span class="line">8 1 0 8</span><br><span class="line">9 1 1 1 2</span><br><span class="line">10 1 0 2</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>​注意每个小朋友只能看到连续的五个围栏，因此可以这样定义dp数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> State = ( <span class="number">1</span> &lt;&lt; <span class="number">5</span> ) - <span class="number">1</span> ; </span><br><span class="line"><span class="type">int</span> dp[ N ][ State + <span class="number">1</span> ] ;  </span><br><span class="line"><span class="comment">// DP数组，dp[i][j]表示处理到第i个围栏且状态为j时的最大高兴小朋友数</span></span><br><span class="line"><span class="type">int</span> b[ N ][ State + <span class="number">1</span> ] ; </span><br><span class="line"><span class="comment">// b[i][j]表示在第i个位置，状态为j时会高兴的小朋友数量</span></span><br></pre></td></tr></table></figure><p>​对于每个小朋友，需要构建令它高兴的mask：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  <span class="type">int</span> left, right;<span class="comment">//围栏起点编号和终点编号</span></span><br><span class="line">  <span class="type">int</span> num_f, num_af;<span class="comment">//喜欢的动物数量和害怕的动物数量</span></span><br><span class="line">  <span class="type">int</span> f[<span class="number">10</span>], af[<span class="number">10</span>];<span class="comment">//记录具体喜欢和害怕的动物</span></span><br><span class="line">&#125;a[C];</span><br></pre></td></tr></table></figure><p>​对于状态转移，当前状态由前一个状态左移一位得到（去掉最高位，最低位可以是0或1）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;<span class="comment">//处理每一个围栏</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= State; j++)&#123;<span class="comment">//枚举状态</span></span><br><span class="line">    <span class="comment">//15 的二进制是 01111（低4位为1，最高位为0）</span></span><br><span class="line">    <span class="comment">//j &amp; 15 的作用是保留状态j的低4位，清除最高位</span></span><br><span class="line">    <span class="comment">//左移一位，相当于所有位向左移动，最低位补0</span></span><br><span class="line">    <span class="comment">// | 1，将最低位变为1</span></span><br><span class="line">    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][((j &amp; (<span class="number">15</span>)) &lt;&lt; <span class="number">1</span>)], </span><br><span class="line">    dp[i - <span class="number">1</span>][((j &amp; (<span class="number">15</span>)) &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)]) + b[i][j];</span><br><span class="line">      <span class="comment">//前一个状态加上当前状态下高兴的小朋友的数量；</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​下面是完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> C = <span class="number">5e4</span> + <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> State = (<span class="number">1</span> &lt;&lt; <span class="number">5</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  <span class="type">int</span> left, right;<span class="comment">//围栏起点编号和终点编号</span></span><br><span class="line">  <span class="type">int</span> num_f, num_af;<span class="comment">//喜欢的动物数量和害怕的动物数量</span></span><br><span class="line">  <span class="type">int</span> f[<span class="number">10</span>], af[<span class="number">10</span>];<span class="comment">//记录具体喜欢和害怕的动物</span></span><br><span class="line">&#125;a[C];</span><br><span class="line"><span class="type">int</span> dp[N][State + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// DP数组，dp[i][j]表示处理到第i个围栏且状态为j时的最大高兴小朋友数</span></span><br><span class="line"><span class="type">int</span> b[N][State + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// b[i][j]表示在第i个位置，状态为j时会高兴的小朋友数量</span></span><br><span class="line"><span class="type">int</span> pa = <span class="number">0</span>, ai = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//怕，爱</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;<span class="comment">//处理每个小朋友</span></span><br><span class="line">    cin &gt;&gt; a[i].left;<span class="comment">//围栏起点</span></span><br><span class="line">    pa = <span class="number">0</span>, ai = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; a[i].num_af &gt;&gt; a[i].num_f;</span><br><span class="line">    <span class="comment">//处理害怕动物</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= a[i].num_af; j++)&#123;</span><br><span class="line">      cin &gt;&gt; a[i].af[j];</span><br><span class="line">      <span class="comment">//计算该害怕动物在五个连续围栏中的相对位置</span></span><br><span class="line">      <span class="type">int</span> pp = (a[i].af[j] - a[i].left + n) % n;</span><br><span class="line">      pa |= (<span class="number">1</span> &lt;&lt; pp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理喜欢的动物</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= a[i].num_f; j++)&#123;</span><br><span class="line">      cin &gt;&gt; a[i].f[j];</span><br><span class="line">      <span class="comment">//计算该喜欢动物在五个连续围栏中的相对位置</span></span><br><span class="line">      <span class="type">int</span> pp = (a[i].f[j] - a[i].left + n) % n;</span><br><span class="line">      ai |= (<span class="number">1</span> &lt;&lt; pp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//枚举所有状态，检查哪些可以使小朋友高兴</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= State; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> ((j &amp; pa) || ((~j) &amp; ai))&#123;</span><br><span class="line">        b[a[i].left][j]++;<span class="comment">//该状态下高兴的小朋友++</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">-1e9</span>;</span><br><span class="line">  <span class="comment">//枚举所有可能的初始状态，注意动物园是环形的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt;= State; mask++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp[<span class="number">0</span>], <span class="number">128</span>, <span class="built_in">sizeof</span>(dp[<span class="number">0</span>]));<span class="comment">//初始化dp为极小值</span></span><br><span class="line">    dp[<span class="number">0</span>][mask] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//处理每一个围栏</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= State; j++)&#123;<span class="comment">//枚举状态</span></span><br><span class="line">        <span class="comment">//15 的二进制是 01111（低4位为1，最高位为0）</span></span><br><span class="line">        <span class="comment">//j &amp; 15 的作用是保留状态j的低4位，清除最高位</span></span><br><span class="line">        <span class="comment">//左移一位，相当于所有位向左移动，最低位补0</span></span><br><span class="line">        <span class="comment">// | 1，将最低位变为1</span></span><br><span class="line">        dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][((j &amp; (<span class="number">15</span>)) &lt;&lt; <span class="number">1</span>)], dp[i - <span class="number">1</span>][((j &amp; (<span class="number">15</span>)) &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)]) + b[i][j];<span class="comment">//前一个状态加上当前状态下高兴的小朋友的数量；</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, dp[n][mask]);<span class="comment">//更新答案</span></span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【状压dp】炮兵阵地</title>
      <link href="/2025/10/22/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0/"/>
      <url>/2025/10/22/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>魔法学院打算在N×M的网格地图上部署炮兵部队以对抗猛兽军团。一个N×M的地图由N行M列组成，地图的每一格可能是山地（用“H”表示），也可能是平原（用“P”表示），如图所示。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围为图中黑色区域。</p><p><img src="http://180.201.136.244/upload/image/20170930/20170930180818_86137.jpg" alt="img"></p><p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其他白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。<br>现在，魔法学院规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少炮兵部队。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行包含两个由空格分割开的正整数，分别表示N和M。<br>接下来的N行，每一行含有连续的M个字符(P或者H)，中间没有空格。按顺序表示地图中每一行的数据。N≤ 100；M ≤ 10。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>仅一行，包含一个整数K，表示最多能摆放的炮兵部队的数量。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">PHPP</span><br><span class="line">PPHH</span><br><span class="line">PPPP</span><br><span class="line">PHPP</span><br><span class="line">PHHP</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>​这题的难点在于一行的mask与上下两行相关，在行与行之间转移时还要考虑上两行的mask。这里可以开三维dp来解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll dp[<span class="number">110</span>][<span class="number">100</span>][<span class="number">100</span>]；<span class="comment">//行，当前行mask，上一行mask</span></span><br></pre></td></tr></table></figure><p>​这样状态转移时就可以顾及到上两行的情况了。</p><p>​完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = (<span class="number">1</span> &lt;&lt; <span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll dp[<span class="number">110</span>][<span class="number">100</span>][<span class="number">100</span>],value[maxn];<span class="comment">//value记录mask中有多少个1</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">110</span>];<span class="comment">//记录地形的mask</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; hefa_mask;<span class="comment">//记录不考虑地形的合法mask，减少时间复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;<span class="comment">//预处理不考虑地形的合法mask</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; m); mask++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; (mask &gt;&gt; <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; (mask &lt;&lt; <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; (mask &gt;&gt; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; (mask &lt;&lt; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">    hefa_mask.<span class="built_in">push_back</span>(mask);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//记录mask中有多少个1</span></span><br><span class="line">  <span class="keyword">if</span> (value[x] != <span class="number">-1</span>) <span class="keyword">return</span> value[x];</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>, X = x;</span><br><span class="line">  <span class="keyword">while</span>(x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">1</span>) ans++;</span><br><span class="line">    x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  value[X] = ans;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_mask</span><span class="params">(<span class="type">int</span> I)</span></span>&#123;<span class="comment">//将地形变为mask</span></span><br><span class="line">  string temp;</span><br><span class="line">  cin &gt;&gt; temp;</span><br><span class="line">  <span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp[i] == <span class="string">&#x27;P&#x27;</span>)&#123;</span><br><span class="line">      mask |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[I] = mask;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mask, <span class="type">int</span> I)</span></span>&#123;</span><br><span class="line">  <span class="comment">//检查当前mask是否与所在行的地形冲突</span></span><br><span class="line">  <span class="comment">//mask中一位为1，地形mask对应位为0</span></span><br><span class="line">  <span class="keyword">if</span> ((mask &amp; (~arr[I])) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(value, <span class="number">-1</span>, <span class="built_in">sizeof</span>(value));</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">pre</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="built_in">build_mask</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> cnt = hefa_mask.<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">//处理第一行</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> m1 = <span class="number">0</span>; m1 &lt; cnt; m1++)&#123;</span><br><span class="line">    <span class="type">int</span> mask = hefa_mask[m1];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(mask, <span class="number">1</span>))&#123;</span><br><span class="line">      dp[<span class="number">1</span>][m1][<span class="number">0</span>] = <span class="built_in">get_sum</span>(mask);</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, dp[<span class="number">1</span>][m1][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果只有第一行，直接输出答案</span></span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理第二行</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> m0 = <span class="number">0</span>; m0 &lt; cnt; m0++)&#123;</span><br><span class="line">    <span class="type">int</span> mask = hefa_mask[m0];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">check</span>(mask, <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m1 = <span class="number">0</span>; m1 &lt; cnt; m1++)&#123;</span><br><span class="line">      <span class="type">int</span> mask1 = hefa_mask[m1];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">check</span>(mask1, <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (mask &amp; mask1) <span class="keyword">continue</span>;<span class="comment">//mask与mask1不能冲突</span></span><br><span class="line">      dp[<span class="number">2</span>][m0][m1] = <span class="built_in">get_sum</span>(mask1) + <span class="built_in">get_sum</span>(mask);</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, dp[<span class="number">2</span>][m0][m1]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//预处理了两行，处理剩余的行</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m0 = <span class="number">0</span>; m0 &lt; cnt; m0++)&#123;</span><br><span class="line">      <span class="type">int</span> mask = hefa_mask[m0];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">check</span>(mask, i)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> m1 = <span class="number">0</span>; m1 &lt; cnt; m1++)&#123;</span><br><span class="line">        <span class="type">int</span> mask1 = hefa_mask[m1];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check</span>(mask1, i - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (mask &amp; mask1) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m2 = <span class="number">0</span>; m2 &lt; cnt; m2++)&#123;</span><br><span class="line">          <span class="type">int</span> mask2 = hefa_mask[m2];</span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">check</span>(mask2, i - <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">if</span> (mask1 &amp; mask2) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">if</span> (mask &amp; mask2) <span class="keyword">continue</span>;</span><br><span class="line">          dp[i][m0][m1] = <span class="built_in">max</span>(dp[i][m0][m1], dp[i - <span class="number">1</span>][m1][m2] + <span class="built_in">get_sum</span>(mask));</span><br><span class="line">          ans = <span class="built_in">max</span>(ans, dp[i][m0][m1]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//其实不用下面的代码了</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> m0 = <span class="number">0</span>; m0 &lt; cnt; m0++)&#123;</span><br><span class="line">    <span class="type">int</span> mask = hefa_mask[m0];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">check</span>(mask, n)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m1 = <span class="number">0</span>; m1 &lt; cnt; m1++)&#123;</span><br><span class="line">      <span class="type">int</span> mask1 = hefa_mask[m1];</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">check</span>(mask1, n - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (mask &amp; mask1) <span class="keyword">continue</span>;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, dp[n][m0][m1]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【状压dp】涂抹果酱</title>
      <link href="/2025/10/22/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91%E6%B6%82%E6%8A%B9%E6%9E%9C%E9%85%B1/"/>
      <url>/2025/10/22/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91%E6%B6%82%E6%8A%B9%E6%9E%9C%E9%85%B1/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Tyvj 两周年庆典要到了，Sam 想为 Tyvj 做一个大蛋糕。蛋糕俯视图是一个 N×M 的矩形，它被划分成 N×M 个边长为 1×1 的小正方形区域（可以把蛋糕当成 N 行 M 列的矩阵）。蛋糕很快做好了，但光秃秃的蛋糕肯定不好看！所以，Sam 要在蛋糕的上表面涂抹果酱。果酱有三种，分别是红果酱、绿果酱、蓝果酱，三种果酱的编号分别为 1,2,3。为了保证蛋糕的视觉效果，Admin 下达了死命令：相邻的区域严禁使用同种果酱。但 Sam 在接到这条命令之前，已经涂好了蛋糕第 K 行的果酱，且无法修改。<br>现在 Sam 想知道：能令 Admin 满意的涂果酱方案有多少种。请输出方案数 mod 106。若不存在满足条件的方案，请输出0。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入共三行。<br>第一行：N,M；<br>第二行：K；<br>第三行：M个整数，表示第K行的方案。<br>字母的详细含义见题目描述，其他参见样例。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出仅一行，为可行的方案总数。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 2 </span><br><span class="line">1 </span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p><img src="http://180.201.136.244/upload/image/20180802/20180802162857_89490.jpg" alt="img"><br>对于30%的数据，1≤N×M≤20；<br>对于60%的数据，1≤N≤1000,1≤M≤3；<br>对于100%的数据，1≤N≤10000,1≤M≤5。</p><p>​原本是一道简单的状压dp，从第k行开始向上下扫。不过由于有三种颜色所以不能用01串来表示mask，而用字符串来表示mask容易爆内存，因此用3进制来表示mask。比较奇怪的是我的代码会超时，被ai奇奇怪怪优化后才过的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">const</span> ll maxn = (<span class="number">1</span> &lt;&lt; <span class="number">5</span>) + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line">string s;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">unordered_map&lt;ll, ll&gt; p;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;<span class="comment">//判断a，b在相邻位置上是否有相同涂色</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> ((a % <span class="number">3</span>) == (b % <span class="number">3</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    a /= <span class="number">3</span>;</span><br><span class="line">    b /= <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">str_to_int</span><span class="params">(string s)</span></span>&#123;<span class="comment">//字符串转mask</span></span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> c : s)&#123;</span><br><span class="line">    res = res * <span class="number">3</span> + (c - <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_dfs</span><span class="params">()</span></span>&#123;<span class="comment">//预处理单行合法mask</span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">length</span>() == m)&#123;</span><br><span class="line">    <span class="type">int</span> mask = <span class="built_in">str_to_int</span>(s);</span><br><span class="line">    arr.<span class="built_in">push_back</span>(mask);</span><br><span class="line">    p[mask] = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="type">char</span> c = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">      s.<span class="built_in">push_back</span>(c);</span><br><span class="line">      <span class="built_in">pre_dfs</span>();</span><br><span class="line">      s.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">back</span>() != c)&#123;</span><br><span class="line">        s.<span class="built_in">push_back</span>(c);</span><br><span class="line">        <span class="built_in">pre_dfs</span>();</span><br><span class="line">        s.<span class="built_in">pop_back</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector &lt;ll&gt; dp[<span class="number">3</span>];<span class="comment">//滚动数组，之前爆内存爆怕了</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; last, cur;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  ll A = <span class="number">0</span>, B = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">  <span class="built_in">pre_dfs</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;<span class="comment">//根据单行合法数量重设dp大小</span></span><br><span class="line">    dp[i].<span class="built_in">resize</span>(arr.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  string sk;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    sk.<span class="built_in">push_back</span>(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> start_state = <span class="built_in">str_to_int</span>(sk);<span class="comment">//第k行mask</span></span><br><span class="line">  <span class="keyword">if</span> (p.<span class="built_in">find</span>(start_state) == p.<span class="built_in">end</span>())&#123;<span class="comment">//第k行不合法，直接输出0</span></span><br><span class="line">    cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> start_id = p[start_state];</span><br><span class="line">  last.<span class="built_in">push_back</span>(start_id);</span><br><span class="line">  dp[<span class="number">1</span>][start_id] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">    cur.<span class="built_in">clear</span>();</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; cur_set;<span class="comment">//用set去重</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; arr.<span class="built_in">size</span>(); mask++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> old_mask : last)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check</span>(arr[mask], arr[old_mask])) <span class="keyword">continue</span>;</span><br><span class="line">        dp[<span class="number">0</span>][mask] += dp[<span class="number">1</span>][old_mask];</span><br><span class="line">        dp[<span class="number">0</span>][mask] %= mod;</span><br><span class="line">        cur_set.<span class="built_in">insert</span>(mask);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.<span class="built_in">assign</span>(cur_set.<span class="built_in">begin</span>(), cur_set.<span class="built_in">end</span>());<span class="comment">//set转vector</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> mask : cur)&#123;<span class="comment">//更新滚动数组</span></span><br><span class="line">      dp[<span class="number">1</span>][mask] = dp[<span class="number">0</span>][mask];</span><br><span class="line">      dp[<span class="number">0</span>][mask] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask : last)&#123;<span class="comment">//更新滚动数组</span></span><br><span class="line">      <span class="keyword">if</span> (cur_set.<span class="built_in">find</span>(mask) == cur_set.<span class="built_in">end</span>())&#123;</span><br><span class="line">        dp[<span class="number">1</span>][mask] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    last = cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> mask : last)&#123;</span><br><span class="line">    A = (A + dp[<span class="number">1</span>][mask]) % mod;<span class="comment">//这里是第一行的情况</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">fill</span>(dp[i].<span class="built_in">begin</span>(), dp[i].<span class="built_in">end</span>(), <span class="number">0</span>);<span class="comment">//初始化dp</span></span><br><span class="line">  &#125;</span><br><span class="line">  dp[<span class="number">1</span>][start_id] = <span class="number">1</span>;</span><br><span class="line">  last.<span class="built_in">clear</span>();</span><br><span class="line">  last.<span class="built_in">push_back</span>(start_id);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = k + <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cur.<span class="built_in">clear</span>();</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; cur_set;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; arr.<span class="built_in">size</span>(); mask++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> old_mask : last)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check</span>(arr[mask], arr[old_mask])) <span class="keyword">continue</span>;</span><br><span class="line">        dp[<span class="number">2</span>][mask] += dp[<span class="number">1</span>][old_mask];</span><br><span class="line">        dp[<span class="number">2</span>][mask] %= mod;</span><br><span class="line">        cur_set.<span class="built_in">insert</span>(mask);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.<span class="built_in">assign</span>(cur_set.<span class="built_in">begin</span>(), cur_set.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> mask : cur)&#123;</span><br><span class="line">      dp[<span class="number">1</span>][mask] = dp[<span class="number">2</span>][mask];</span><br><span class="line">      dp[<span class="number">2</span>][mask] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask : last)&#123;</span><br><span class="line">      <span class="keyword">if</span> (cur_set.<span class="built_in">find</span>(mask) == cur_set.<span class="built_in">end</span>())&#123;</span><br><span class="line">        dp[<span class="number">1</span>][mask] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    last = cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> mask : last)&#123;</span><br><span class="line">    B = (B + dp[<span class="number">1</span>][mask]) % mod;<span class="comment">//这里是第n行情况</span></span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; A * B % mod &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​看了别人的写法，发现滚动数组是不必要的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line">string s;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> ((a % <span class="number">3</span>) == (b % <span class="number">3</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    a /= <span class="number">3</span>;</span><br><span class="line">    b /= <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">str_to_int</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> c : s)&#123;</span><br><span class="line">    res = res * <span class="number">3</span> + (c - <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_dfs</span><span class="params">()</span></span>&#123;<span class="comment">//当然，题解是直接枚举3进制mask</span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">length</span>() == m)&#123;</span><br><span class="line">    <span class="type">int</span> mask = <span class="built_in">str_to_int</span>(s);</span><br><span class="line">    arr.<span class="built_in">push_back</span>(mask);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="type">char</span> c = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">      s.<span class="built_in">push_back</span>(c);</span><br><span class="line">      <span class="built_in">pre_dfs</span>();</span><br><span class="line">      s.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">back</span>() != c)&#123;</span><br><span class="line">        s.<span class="built_in">push_back</span>(c);</span><br><span class="line">        <span class="built_in">pre_dfs</span>();</span><br><span class="line">        s.<span class="built_in">pop_back</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">ll m1, m2, dp[<span class="number">10010</span>][<span class="number">300</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">  <span class="built_in">pre_dfs</span>();</span><br><span class="line">  <span class="type">int</span> sk, id = <span class="number">-1</span>;</span><br><span class="line">  s.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    s.<span class="built_in">push_back</span>(c);</span><br><span class="line">  &#125;</span><br><span class="line">  sk = <span class="built_in">str_to_int</span>(s);</span><br><span class="line">  <span class="comment">//用arr的索引代替mask</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] == sk)&#123;</span><br><span class="line">      id = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (id == <span class="number">-1</span>)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dp[k][id] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//可以看到这里的状态转移十分简洁</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; arr.<span class="built_in">size</span>(); mask++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> old_mask = <span class="number">0</span>; old_mask &lt; arr.<span class="built_in">size</span>(); old_mask++)&#123;</span><br><span class="line">        <span class="comment">//注意这里的mask是arr的索引，arr[mask]才是真正的掩码</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(arr[mask], arr[old_mask]))&#123;</span><br><span class="line">          dp[i][mask] = (dp[i][mask] + dp[i + <span class="number">1</span>][old_mask]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = k + <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; arr.<span class="built_in">size</span>(); mask++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> old_mask = <span class="number">0</span>; old_mask &lt; arr.<span class="built_in">size</span>(); old_mask++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(arr[mask], arr[old_mask]))&#123;</span><br><span class="line">          dp[i][mask] = (dp[i][mask] + dp[i - <span class="number">1</span>][old_mask]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; arr.<span class="built_in">size</span>(); mask++)&#123;</span><br><span class="line">    m1 = (m1 + dp[<span class="number">1</span>][mask]) % mod;</span><br><span class="line">    m2 = (m2 + dp[n][mask]) % mod;</span><br><span class="line">  &#125;;</span><br><span class="line">  cout &lt;&lt; m1 * m2 % mod &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/10/21/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91LittleKing/"/>
      <url>/2025/10/21/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91LittleKing/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在解决了关于象和车的趣味问题之后，Petya 决定他想学习下国际象棋。他开始学习规则，并发现游戏中最重要的棋子是<strong>王</strong>。</p><p>王可以移动到任何相邻的格子（这样的格子最多有八个）。因此，如果两个王位于相邻的格子，它们就处于<strong>互相攻击</strong>的状态。</p><p>当然，Petya 想知道的第一个问题是：在一个大小为 n × n 的棋盘上，有多少种方式可以放置 k 个王，使得它们之间<strong>没有两个王处于互相攻击的位置</strong>。请帮助他！</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入文件包含两个整数 n (1 ≤ n ≤ 10) 和 k (0 ≤ k ≤ n²)。</p><p><strong>输出</strong></p><p>输出一行，表示在给定大小的棋盘上放置给定数量的王，且没有任何两个王互相攻击的总方法数。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure><p>​二维状压dp，直接枚举所有情况是不可能的，但是可以分别对每一行枚举这一行的所有情况。可以做如下定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ll dp[maxn][<span class="number">1</span> &lt;&lt; maxn][maxn * <span class="number">10</span>];<span class="comment">//行，单行mask，到当前行位置放的国王个数</span></span><br><span class="line"><span class="type">int</span> s[<span class="number">1</span> &lt;&lt; maxn], cnt, sum[<span class="number">1</span> &lt;&lt; maxn];</span><br><span class="line"><span class="comment">//s记录了合法的单行mask，sum记录了合法mask中有几个国王，cnt是计数器</span></span><br></pre></td></tr></table></figure><p>​先处理单行情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)&#123;<span class="comment">//枚举所有mask</span></span><br><span class="line">    <span class="keyword">if</span> (!(i &amp; (i &gt;&gt; <span class="number">1</span>)))&#123;<span class="comment">//说明没有相邻的1挨着</span></span><br><span class="line">      s[cnt] = i;<span class="comment">//记录合法mask</span></span><br><span class="line">      sum[cnt++] = <span class="built_in">get_sum</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​然后在行间进行状态转移：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;<span class="comment">//检查上下两行之间是否合法</span></span><br><span class="line">  <span class="keyword">if</span> (a &amp; b) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//同一列有国王</span></span><br><span class="line">  <span class="keyword">if</span> ((a &gt;&gt; <span class="number">1</span>) &amp; b) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//左上方有国王</span></span><br><span class="line">  <span class="keyword">if</span> ((a &lt;&lt; <span class="number">1</span>) &amp; b) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//右上方有国王</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)<span class="comment">//第一行预处理了，从第二行开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; cnt; a++)<span class="comment">//枚举当前行mask</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; cnt; b++)<span class="comment">//枚举上一行mask</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> c = sum[a]; c &lt;= k; c++)<span class="comment">//枚举可能的国王数量</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(s[a], s[b]))<span class="comment">//如果上下两行之间合法</span></span><br><span class="line">          dp[i][a][c] += dp[i - <span class="number">1</span>][b][c - sum[a]];<span class="comment">//累加方案数</span></span><br></pre></td></tr></table></figure><p>​来看完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll maxn = <span class="number">11</span>;</span><br><span class="line">ll n, k;</span><br><span class="line">ll dp[maxn][<span class="number">1</span> &lt;&lt; maxn][maxn * <span class="number">10</span>];<span class="comment">//行，单行mask，到当前行位置放的国王个数</span></span><br><span class="line"><span class="type">int</span> s[<span class="number">1</span> &lt;&lt; maxn], cnt, sum[<span class="number">1</span> &lt;&lt; maxn];</span><br><span class="line"><span class="comment">//s记录了合法的单行mask，sum记录了合法mask中有几个国王，cnt是计数器</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//计算mask中有多少个1</span></span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">1</span>) cnt++;</span><br><span class="line">    x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)&#123;<span class="comment">//枚举所有mask</span></span><br><span class="line">    <span class="keyword">if</span> (!(i &amp; (i &gt;&gt; <span class="number">1</span>)))&#123;<span class="comment">//说明没有相邻的1挨着</span></span><br><span class="line">      s[cnt] = i;<span class="comment">//记录合法mask</span></span><br><span class="line">      sum[cnt++] = <span class="built_in">get_sum</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;<span class="comment">//检查上下两行之间是否合法</span></span><br><span class="line">  <span class="keyword">if</span> (a &amp; b) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//同一列有国王</span></span><br><span class="line">  <span class="keyword">if</span> ((a &gt;&gt; <span class="number">1</span>) &amp; b) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//左上方有国王</span></span><br><span class="line">  <span class="keyword">if</span> ((a &lt;&lt; <span class="number">1</span>) &amp; b) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//右上方有国王</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">  cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">pre</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)&#123;<span class="comment">//预处理第一行</span></span><br><span class="line">    dp[<span class="number">1</span>][i][sum[i]] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;<span class="comment">//第一行预处理了，从第二行开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; cnt; a++)&#123;<span class="comment">//枚举当前行mask</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; cnt; b++)&#123;<span class="comment">//枚举上一行mask</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = sum[a]; c &lt;= k; c++)&#123;<span class="comment">//枚举可能的国王数量</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">check</span>(s[a], s[b]))&#123;<span class="comment">//如果上下两行之间合法</span></span><br><span class="line">            dp[i][a][c] += dp[i - <span class="number">1</span>][b][c - sum[a]];<span class="comment">//累加方案数</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">    ans += dp[n][i][k];</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【数位dp】数字计数</title>
      <link href="/2025/10/20/%E3%80%90%E6%95%B0%E4%BD%8Ddp%E3%80%91%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0/"/>
      <url>/2025/10/20/%E3%80%90%E6%95%B0%E4%BD%8Ddp%E3%80%91%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p> 给定两个正整数 a 和 b，求在[a,b]中的所有整数中，每个数码(digit)各出现了多少次。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>中仅包含一行两个整数 a、b，含义如上所述。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>包含一行 10 个整数，分别表示 0-9 在[a,b]中出现了多少次。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 99</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 20 20 20 20 20 20 20 20 20</span><br></pre></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>30%的数据中，a&lt;&#x3D;b&lt;&#x3D;10^6^；<br>100%的数据中，a&lt;&#x3D;b&lt;&#x3D;10^12^。</p><p>​很多题解都是用递推做的，终于找到一篇dfs做的了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll a, b;</span><br><span class="line"><span class="comment">//dp[pos][当前位下目标dig的个数]</span></span><br><span class="line"><span class="comment">//在前pos位中出现sum个dig对后面的dfs没有影响，所以可以用dp[pos][sum]来记忆化</span></span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">20</span>], arr[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">bool</span> limited, <span class="type">bool</span> leader, <span class="type">int</span> dig, ll sum)</span></span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//所有位处理完毕，返回sum</span></span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">  <span class="comment">//记忆化</span></span><br><span class="line">  <span class="keyword">if</span> (!limited &amp;&amp; !leader &amp;&amp; dp[pos][sum] != <span class="number">-1</span>) <span class="keyword">return</span> dp[pos][sum];</span><br><span class="line">  <span class="type">int</span> up = limited ? arr[pos] : <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)&#123;</span><br><span class="line">    ans += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, limited &amp;&amp; (i == up), leader &amp;&amp; (i == <span class="number">0</span>), dig, sum + (!(leader &amp;&amp; i == <span class="number">0</span>) &amp;&amp; (i == dig)));</span><br><span class="line">    <span class="comment">//当i == dig 并且没有前导0时sum++</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!limited &amp;&amp; !leader) dp[pos][sum] = ans;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x, ll d)</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span>) arr[pos++] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x)&#123;</span><br><span class="line">    arr[pos++] = x % <span class="number">10</span>;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dfs</span>(pos - <span class="number">1</span>, <span class="literal">true</span>, <span class="literal">true</span>, d, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>(b, i) - <span class="built_in">solve</span>(a - <span class="number">1</span>, i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数位dp】恨7不成妻</title>
      <link href="/2025/10/20/%E3%80%90%E6%95%B0%E4%BD%8Ddp%E3%80%91%E6%81%A87%E4%B8%8D%E6%88%90%E5%A6%BB/"/>
      <url>/2025/10/20/%E3%80%90%E6%95%B0%E4%BD%8Ddp%E3%80%91%E6%81%A87%E4%B8%8D%E6%88%90%E5%A6%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>单身!<br>依然单身！<br>吉哥依然单身！<br>DS级码农吉哥依然单身！<br>所以，他生平最恨情人节，不管是214还是77，他都讨厌！</p><p>吉哥观察了214和77这两个数，发现：<br>2 + 1 + 4 &#x3D; 7<br>7 + 7 &#x3D; 7 * 2<br>77 &#x3D; 7 * 11<br>最终，他发现原来这一切归根到底都是因为和7有关！所以，他现在甚至讨厌一切和7有关的数！</p><p>什么样的数和7有关呢？</p><p>如果一个整数符合下面3个条件之一，那么我们就说这个整数和7有关——<br>1、整数中某一位是7；<br>2、整数的每一位加起来的和是7的整数倍；<br>3、这个整数是7的整数倍；</p><p>现在问题来了：吉哥想知道在一定区间内和7无关的数字的平方和。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入数据的第一行是case数T(1 &lt;&#x3D; T &lt;&#x3D; 50)，然后接下来的T行表示T个case;每个case在一行内包含两个正整数L, R(1 &lt;&#x3D; L &lt;&#x3D; R &lt;&#x3D; 10^18^)。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>请计算[L,R]中和7无关的数字的平方和，并将结果对10^9^ + 7 求模后输出。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 9</span><br><span class="line">10 11</span><br><span class="line">17 17</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">236</span><br><span class="line">221</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>​和一般的数位dp不同，这题不是计算个数而是计算平方和。这里开一个结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  ll cnt, sum, sum2;<span class="comment">//分别表示符合条件的个数、总和、平方和</span></span><br><span class="line">&#125;dp[<span class="number">20</span>][<span class="number">7</span>][<span class="number">7</span>];<span class="comment">//当前数位、当前各数位上数之和模7，当前数模7</span></span><br></pre></td></tr></table></figure><p>​再来看转移方程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">node temp = node&#123;0, 0, 0&#125;;</span><br><span class="line">for (int i = 0; i &lt;= up; i++)&#123;</span><br><span class="line">  if (i == 7) continue;</span><br><span class="line">  node j = dfs(pos - 1, (sum + i ) % 7, (num * 10 + i) % 7, limited &amp;&amp; i == up);</span><br><span class="line">  ll B = i * pw[pos];</span><br><span class="line">  temp.cnt = (temp.cnt + j.cnt) % mod;</span><br><span class="line">  temp.sum = (temp.sum + j.cnt * B + j.sum) % mod;</span><br><span class="line">  temp.sum2 = (temp.sum2 + j.cnt * B % mod * B % mod + j.sum2 + 2 * j.sum % mod * B % mod) % mod;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​j是当前位的后缀，当前数字可以视为 i * pw[pos]（pw是预处理好的1^pos^） + 后缀，那么当前数字的平方就等于（前缀 + 后缀）^2^ &#x3D; 前缀^2^ + 2 * 前缀 * 后缀 + 后缀^2^。同时当前数有多少个后缀，当前前缀就要参与多少次计算，因此当前数的平方和为 cnt * 前缀^2^ + 2 * 前缀 * 后缀 + 后缀^2^。计算完当前数的平方和后再在sum2上累加。</p><p>​接下来展示完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll l, r;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">25</span>];</span><br><span class="line">ll pw[<span class="number">25</span>];<span class="comment">//记录pow(10, i) % mod;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  ll cnt, sum, sum2;<span class="comment">////分别表示符合条件的个数、总和、平方和</span></span><br><span class="line">&#125;dp[<span class="number">20</span>][<span class="number">7</span>][<span class="number">7</span>];<span class="comment">//当前数位、当前各数位上数之和模7，当前数模7</span></span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> sum, <span class="type">int</span> num, <span class="type">bool</span> limited)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) <span class="keyword">return</span> node&#123;sum &amp;&amp; num, <span class="number">0</span>, <span class="number">0</span>&#125;;<span class="comment">//表示有一个解</span></span><br><span class="line">  <span class="keyword">if</span> (!limited &amp;&amp; dp[pos][sum][num].cnt != <span class="number">-1</span>) <span class="keyword">return</span> dp[pos][sum][num];<span class="comment">//记忆化</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> up = limited ? arr[pos] : <span class="number">9</span>;</span><br><span class="line">  node temp = node&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">7</span>) <span class="keyword">continue</span>;<span class="comment">//不能含有7</span></span><br><span class="line">    <span class="comment">//j在这里表示后缀</span></span><br><span class="line">    node j = <span class="built_in">dfs</span>(pos - <span class="number">1</span>, (sum + i ) % <span class="number">7</span>, (num * <span class="number">10</span> + i) % <span class="number">7</span>, limited &amp;&amp; i == up);</span><br><span class="line">    <span class="comment">//B在这里表示前缀</span></span><br><span class="line">    ll B = i * pw[pos];</span><br><span class="line">    <span class="comment">//个数累加</span></span><br><span class="line">    temp.cnt = (temp.cnt + j.cnt) % mod;</span><br><span class="line">    <span class="comment">//和累加，注意这里的有多少个后缀，前缀就要加多少次，所以是j.cnt * B</span></span><br><span class="line">    temp.sum = (temp.sum + j.cnt * B + j.sum) % mod;</span><br><span class="line">    <span class="comment">//平方和累加，同理前缀要多次累加</span></span><br><span class="line">    temp.sum2 = (temp.sum2 + j.cnt * B % mod * B % mod + j.sum2 + <span class="number">2</span> * j.sum % mod * B % mod) % mod;    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!limited) dp[pos][sum][num] = temp;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_sum</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(x)&#123;</span><br><span class="line">    arr[pos++] = x % <span class="number">10</span>;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span>) arr[pos++] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dfs</span>(pos - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>).sum2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">  pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i++)&#123;</span><br><span class="line">    pw[i] = pw[i - <span class="number">1</span>] * <span class="number">10</span> % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">get_sum</span>(r) - <span class="built_in">get_sum</span>(l - <span class="number">1</span>) + mod) % mod &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数位dp】Amount of Degrees</title>
      <link href="/2025/10/18/Amount%20of%20Degrees/"/>
      <url>/2025/10/18/Amount%20of%20Degrees/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>编写一个程序，计算在区间 [X, Y] 内，有多少个整数可以表示为 <strong>恰好 K 个不同的 B 的整数次幂之和</strong>。<br>设 X&#x3D;15, Y&#x3D;20, K&#x3D;2, B&#x3D;2。<br>在此示例中，有 3 个数可以表示为恰好两个不同的 2 的整数次幂之和：<br>17 &#x3D; 2^4^+2^0^,<br>18 &#x3D; 2^4^+2^1^,<br>20 &#x3D; 2^4^+2^2^.</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行包含两个整数 X 和 Y，用空格分隔（1 ≤ X ≤ Y ≤ 2³¹−1）。<br>接下来两行分别包含整数 K 和 B（1 ≤ K ≤ 20；2 ≤ B ≤ 10）。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出一个整数，表示在 [X, Y] 范围内，可以表示为恰好 K 个不同的 B 的整数次幂之和的数的个数。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">15 20</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>​B进制下的数位dp，由于K最大只去到20，因此可以用dfs来做。dp数组需要记录两个状态，一个是当前计算到哪一位了，另一个是还需要几位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll x, y, k, b;</span><br><span class="line"><span class="comment">//dp[当前是第i位][还要j个数字]</span></span><br><span class="line">ll dp[<span class="number">35</span>][<span class="number">25</span>], arr[<span class="number">35</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//初始化dp数组-1，表示没有计算过</span></span><br><span class="line">  <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll pos, ll k, <span class="type">bool</span> limit)</span></span>&#123;</span><br><span class="line">  <span class="comment">//k == 0表示k个数都已经取完了，该方案可行，总数加1</span></span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//pos &lt; 0 表示全部位都试过了，但该方案不可行</span></span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//当前状态之前算过，记忆化</span></span><br><span class="line">  <span class="keyword">if</span> (!limit &amp;&amp; dp[pos][k] != <span class="number">-1</span>) <span class="keyword">return</span> dp[pos][k];</span><br><span class="line">  <span class="comment">//计算当前位的上限</span></span><br><span class="line">  <span class="type">int</span> up = limit ? arr[pos] : <span class="number">9</span>;</span><br><span class="line">  ll temp = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//i要不取上限，要不在0，1之间取（表示不取或取）</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up &amp;&amp; i &lt;= <span class="number">1</span>; i++)&#123;</span><br><span class="line">    temp += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, k - i, limit &amp;&amp; i == up);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//非限制，存储dp</span></span><br><span class="line">  <span class="keyword">if</span> (!limit) dp[pos][k] = temp;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get_num</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//统计每一位的数字到arr中，用于limit的判断</span></span><br><span class="line">  <span class="keyword">while</span>(x)&#123;</span><br><span class="line">    arr[pos++] = x % b;</span><br><span class="line">    x /= b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dfs</span>(pos - <span class="number">1</span>, k, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">  cin &gt;&gt; k &gt;&gt; b;</span><br><span class="line">  <span class="comment">//类前缀和计算</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">get_num</span>(y) - <span class="built_in">get_num</span>(x - <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树型dp】基环树上的dp</title>
      <link href="/2025/10/14/%E5%9F%BA%E7%8E%AF%E6%A0%91%E4%B8%8A%E7%9A%84dp/"/>
      <url>/2025/10/14/%E5%9F%BA%E7%8E%AF%E6%A0%91%E4%B8%8A%E7%9A%84dp/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Z国的骑士团是一个很有势力的组织，帮会中汇聚了来自各地的精英。他们劫富济贫，惩恶扬善，受到社会各界的赞扬。<br>最近发生了一件可怕的事情，邪恶的Y国发动了一场针对Z国的侵略战争。战火绵延五百里，在和平环境中安逸了数百年的Z国又怎能抵挡的住Y国的军队。于是人们把所有的希望都寄托在了骑士团的身上，就像期待有一个真龙天子的降生，带领正义打败邪恶。<br>骑士团是肯定具有打败邪恶势力的能力的，但是骑士们互相之间往往有一些矛盾。每个骑士都有且仅有一个自己最厌恶的骑士（当然不是他自己），他是绝对不会与自己最厌恶的人一同出征的。<br>战火绵延，人民生灵涂炭，组织起一个骑士军团加入战斗刻不容缓！国王交给了你一个艰巨的任务，从所有的骑士中选出一个骑士军团，使得军团内没有矛盾的两人（不存在一个骑士与他最痛恨的人一同被选入骑士军团的情况），并且，使得这支骑士军团最具有战斗力。<br>为了描述战斗力，我们将骑士按照1至N编号，给每名骑士一个战斗力的估计，一个军团的战斗力为所有骑士的战斗力总和。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行包含一个正整数N，描述骑士团的人数。<br>接下来N行，每行两个正整数，按顺序描述每一名骑士的战斗力和他最痛恨的骑士。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>应包含一行，包含一个整数，表示你所选出的骑士军团的战斗力。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">10 2</span><br><span class="line">20 3</span><br><span class="line">30 1</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>对于30%的测试数据，满足N ≤ 10；<br>对于60%的测试数据，满足N ≤ 100；<br>对于80%的测试数据，满足N ≤ 10 000。<br>对于100%的测试数据，满足N ≤ 1 000 000，每名骑士的战斗力都是不大于  1 000 000的正整数。</p><p>​正如标题所说，这题是到树型dp，不过这题的树是个基环树。将每个骑士视作子节点，将这个骑士讨厌的骑士视为他的父节点，由此建树，只有在根节点处才有可能成环。因此这题的解法和经典题目“没有上司的舞会”很像，只不过要加入对基环树的判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, fa[maxn], root;</span><br><span class="line">ll arr[maxn], dp[maxn][<span class="number">2</span>], ans = <span class="number">0</span>;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; adj[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DP</span><span class="params">(<span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">  vis[cur] = <span class="number">1</span>;</span><br><span class="line">  dp[cur][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//不选当前骑士</span></span><br><span class="line">  dp[cur][<span class="number">1</span>] = arr[cur];<span class="comment">//选当前骑士</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[cur])&#123;</span><br><span class="line">    <span class="keyword">if</span> (v != root)&#123;</span><br><span class="line">      <span class="built_in">DP</span>(v);</span><br><span class="line">      dp[cur][<span class="number">0</span>] += <span class="built_in">max</span>(dp[v][<span class="number">1</span>], dp[v][<span class="number">0</span>]);<span class="comment">//父亲不选，管他儿子选不选</span></span><br><span class="line">      dp[cur][<span class="number">1</span>] += dp[v][<span class="number">0</span>];<span class="comment">//父亲选了，儿子不能选</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      dp[v][<span class="number">1</span>] = -maxn;<span class="comment">//儿子为根，说明成基环树了</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_circle</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  vis[x] = <span class="number">1</span>;</span><br><span class="line">  root = x;</span><br><span class="line">  <span class="keyword">while</span>(!vis[fa[root]])&#123;<span class="comment">//找根节点</span></span><br><span class="line">    root = fa[root];</span><br><span class="line">    vis[root] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DP</span>(root);<span class="comment">//第一次DP：强制不选fa[root]（通过v != root条件）</span></span><br><span class="line">  ll temp = <span class="built_in">max</span>(dp[root][<span class="number">0</span>], dp[root][<span class="number">1</span>]);</span><br><span class="line">  vis[root] = <span class="number">1</span>;</span><br><span class="line">  root = fa[root];</span><br><span class="line">  <span class="built_in">DP</span>(root);<span class="comment">//第二次DP：强制不选原来的root</span></span><br><span class="line">  ans += <span class="built_in">max</span>(temp, <span class="built_in">max</span>(dp[root][<span class="number">0</span>], dp[root][<span class="number">1</span>]));</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="type">int</span> no;</span><br><span class="line">    cin &gt;&gt; no;</span><br><span class="line">    adj[no].<span class="built_in">push_back</span>(i);</span><br><span class="line">    fa[i] = no;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) <span class="built_in">find_circle</span>(i);<span class="comment">//可能为森林</span></span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面的代码在TK那过不了，64mb的内存限制我刚好卡在65mb，没办法只好不开vector了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, fa[maxn], root, arr[maxn];</span><br><span class="line">ll dp[maxn][<span class="number">2</span>], ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> head[maxn], nxt[maxn], to[maxn], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  nxt[++cnt] = head[u];</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">  to[cnt] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DP</span><span class="params">(<span class="type">int</span> cur)</span></span>&#123;</span><br><span class="line">  vis[cur] = <span class="number">1</span>;</span><br><span class="line">  dp[cur][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  dp[cur][<span class="number">1</span>] = arr[cur];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[cur]; i; i = nxt[i])&#123;</span><br><span class="line">    <span class="type">int</span> v = to[i];</span><br><span class="line">    <span class="keyword">if</span> (v != root)&#123;</span><br><span class="line">      <span class="built_in">DP</span>(v);</span><br><span class="line">      dp[cur][<span class="number">0</span>] += <span class="built_in">max</span>(dp[v][<span class="number">1</span>], dp[v][<span class="number">0</span>]);</span><br><span class="line">      dp[cur][<span class="number">1</span>] += dp[v][<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      dp[v][<span class="number">1</span>] = -maxn;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_circle</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">  root = x;</span><br><span class="line">  <span class="keyword">while</span>(!vis[fa[root]])&#123;</span><br><span class="line">    root = fa[root];</span><br><span class="line">    vis[root] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DP</span>(root);</span><br><span class="line">  ll temp = <span class="built_in">max</span>(dp[root][<span class="number">0</span>], dp[root][<span class="number">1</span>]);</span><br><span class="line">  vis[root] = <span class="number">1</span>;</span><br><span class="line">  root = fa[root];</span><br><span class="line">  <span class="built_in">DP</span>(root);</span><br><span class="line">  ans += <span class="built_in">max</span>(temp, <span class="built_in">max</span>(dp[root][<span class="number">0</span>], dp[root][<span class="number">1</span>]));</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="type">int</span> no;</span><br><span class="line">    cin &gt;&gt; no;</span><br><span class="line">    <span class="built_in">add_edge</span>(no, i);</span><br><span class="line">    fa[i] = no;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) <span class="built_in">find_circle</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【链表】单链表分段逆转</title>
      <link href="/2025/10/13/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%86%E6%AE%B5%E9%80%86%E8%BD%AC/"/>
      <url>/2025/10/13/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%86%E6%AE%B5%E9%80%86%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>​给定一个带头结点的单链表和一个整数<em>K</em>，要求你将链表中的每<em>K</em>个结点做一次逆转。例如给定单链表 1→2→3→4→5→6 和 <em>K</em>&#x3D;3，你需要将链表改造成 3→2→1→6→5→4；如果 <em>K</em>&#x3D;4，则应该得4→3→2→1→5→6。</p><h3 id="裁判测试程序样例："><a href="#裁判测试程序样例：" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data; <span class="comment">/* 存储结点数据 */</span></span><br><span class="line">    PtrToNode   Next; <span class="comment">/* 指向下一个结点的指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List; <span class="comment">/* 定义单链表类型 */</span></span><br><span class="line"></span><br><span class="line">List <span class="title function_">ReadInput</span><span class="params">()</span>; <span class="comment">/* 裁判实现，细节不表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">( List L )</span>; <span class="comment">/* 裁判实现，细节不表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">K_Reverse</span><span class="params">( List L, <span class="type">int</span> K )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List L;</span><br><span class="line">    <span class="type">int</span> K;</span><br><span class="line"></span><br><span class="line">    L = ReadInput();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;K);</span><br><span class="line">    K_Reverse( L, K );</span><br><span class="line">    PrintList( L );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 1 5 6</span><br></pre></td></tr></table></figure><p>​这道题也是个逆天题，不知道这个题能拿来干嘛用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">K_Reverse</span><span class="params">( List L, <span class="type">int</span> K )</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (K &lt;= <span class="number">1</span>) <span class="keyword">return</span> ;<span class="comment">//长度为1不用逆转</span></span><br><span class="line">  PtrToNode pre = L;</span><br><span class="line">  PtrToNode cur = L-&gt;Next;</span><br><span class="line">  <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;<span class="comment">//计数器</span></span><br><span class="line">    PtrToNode last = cur;<span class="comment">//逆转段的尾指针</span></span><br><span class="line">    <span class="keyword">while</span>(last != <span class="literal">NULL</span> &amp;&amp; cnt &lt; K)&#123;</span><br><span class="line">      last = last-&gt;Next;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="literal">NULL</span>) <span class="keyword">break</span>;<span class="comment">//尾指针超过了链表末尾，按题意这段不用逆转</span></span><br><span class="line">    PtrToNode prev = <span class="literal">NULL</span>;</span><br><span class="line">    PtrToNode next = <span class="literal">NULL</span>;</span><br><span class="line">    PtrToNode tail = cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; i++)&#123;</span><br><span class="line">      next = cur-&gt;Next;<span class="comment">//存储原本的next</span></span><br><span class="line">      cur-&gt;Next = prev;<span class="comment">//当前的节点的next变为前节点</span></span><br><span class="line">      prev = cur;<span class="comment">//前节点后移，i==k时prev代表当前段的尾节点</span></span><br><span class="line">      cur = next;<span class="comment">//当前节点后移，i==k时cur代表下一段的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;Next = prev;<span class="comment">//pre为上一段的尾节点，其next为当前段的尾节点</span></span><br><span class="line">    tail-&gt;Next = cur;<span class="comment">//tail为这一段的原头节点（逆转后是尾节点），其next是下一段的头节点</span></span><br><span class="line">    pre = tail;<span class="comment">//上一段尾节点更新为当前段的尾节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【链表】带头节点的链表操作集</title>
      <link href="/2025/10/13/%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C%E9%9B%86/"/>
      <url>/2025/10/13/%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>​带头节点的链表，意思就是头节点仅起内存地址索引作用，不实际存储数据。</p><p>​来看看作业题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR NULL</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span><span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="type">bool</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">PtrToLNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToLNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode Position;</span><br><span class="line"><span class="keyword">typedef</span> PtrToLNode List;</span><br><span class="line"></span><br><span class="line">List <span class="title function_">MakeEmpty</span><span class="params">()</span>; </span><br><span class="line">Position <span class="title function_">Find</span><span class="params">( List L, ElementType X )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert</span><span class="params">( List L, ElementType X, Position P )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Delete</span><span class="params">( List L, Position P )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List L;</span><br><span class="line">    ElementType X;</span><br><span class="line">    Position P;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line"></span><br><span class="line">    L = MakeEmpty();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> ( N-- ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        flag = Insert(L, X, L-&gt;Next);</span><br><span class="line">        <span class="keyword">if</span> ( flag==<span class="literal">false</span> ) <span class="built_in">printf</span>(<span class="string">&quot;Wrong Answer\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> ( N-- ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        P = Find(L, X);</span><br><span class="line">        <span class="keyword">if</span> ( P == ERROR )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Finding Error: %d is not in.\n&quot;</span>, X);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = Delete(L, P);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is found and deleted.\n&quot;</span>, X);</span><br><span class="line">            <span class="keyword">if</span> ( flag==<span class="literal">false</span> )</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Wrong Answer.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flag = Insert(L, X, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( flag==<span class="literal">false</span> ) <span class="built_in">printf</span>(<span class="string">&quot;Wrong Answer\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is inserted as the last element.\n&quot;</span>, X);</span><br><span class="line">    P = (Position)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    flag = Insert(L, X, P);</span><br><span class="line">    <span class="keyword">if</span> ( flag==<span class="literal">true</span> ) <span class="built_in">printf</span>(<span class="string">&quot;Wrong Answer\n&quot;</span>);</span><br><span class="line">    flag = Delete(L, P);</span><br><span class="line">    <span class="keyword">if</span> ( flag==<span class="literal">true</span> ) <span class="built_in">printf</span>(<span class="string">&quot;Wrong Answer\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> ( P=L-&gt;Next; P; P = P-&gt;Next ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, P-&gt;Data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><p>​要我们完成下列函数的编写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List <span class="title function_">MakeEmpty</span><span class="params">()</span>; </span><br><span class="line">Position <span class="title function_">Find</span><span class="params">( List L, ElementType X )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert</span><span class="params">( List L, ElementType X, Position P )</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Delete</span><span class="params">( List L, Position P )</span>;</span><br></pre></td></tr></table></figure><p>​具体的就看代码注释吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">List <span class="title function_">MakeEmpty</span><span class="params">()</span>&#123;<span class="comment">//init头节点</span></span><br><span class="line">    <span class="comment">//这个malloc写法也要记住，c++的new确实方便许多了</span></span><br><span class="line">    <span class="comment">//注意变量名前要加struct，这里List是LNode的指针</span></span><br><span class="line">    List head = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    head-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">Position <span class="title function_">Find</span><span class="params">( List L, ElementType X )</span>&#123;</span><br><span class="line">    <span class="comment">//头节点不存储数据，因此第一个元素是头节点的next</span></span><br><span class="line">    Position cur = L-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;Data == X) <span class="keyword">break</span>;</span><br><span class="line">        cur = cur-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert</span><span class="params">( List L, ElementType X, Position P )</span>&#123;</span><br><span class="line">    Position pre = L;</span><br><span class="line">    Position cur = L-&gt;Next;</span><br><span class="line">    PtrToLNode new_p = (PtrToLNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span> &amp;&amp; P != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Wrong Position for Insertion\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur == P)&#123;</span><br><span class="line">            new_p-&gt;Data = X;</span><br><span class="line">            new_p-&gt;Next = P;</span><br><span class="line">            pre-&gt;Next = new_p;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Wrong Position for Insertion\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Delete</span><span class="params">( List L, Position P )</span>&#123;</span><br><span class="line">    Position pre = L;</span><br><span class="line">    Position cur = L-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == P)&#123;</span><br><span class="line">            pre-&gt;Next = cur-&gt;Next;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur -&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Wrong Position for Deletion\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模板】c语言快排</title>
      <link href="/2025/10/13/c%E8%AF%AD%E8%A8%80%E5%BF%AB%E6%8E%92/"/>
      <url>/2025/10/13/c%E8%AF%AD%E8%A8%80%E5%BF%AB%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<p>​c语言的快排不像c++一样有直接内置好的函数，排序函数需要自己写，以下为代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;<span class="comment">//void*是通用指针</span></span><br><span class="line">    ElementType fa = *(<span class="type">const</span> ElementType *)a;<span class="comment">//先用(const ElementType *)强制转换指针类型</span></span><br><span class="line">    ElementType fb = *(<span class="type">const</span> ElementType *)b;<span class="comment">//再用一个*解引用</span></span><br><span class="line">    <span class="keyword">if</span> (fa &lt; fb) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//降序排序，a比b小，a在b前</span></span><br><span class="line">    <span class="keyword">if</span> (fa &gt; fb) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ElementType <span class="title function_">Median</span><span class="params">( ElementType A[], <span class="type">int</span> N )</span> &#123;</span><br><span class="line">    ElementType B[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        B[i] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数组，数量， 当个元素大小，比较函数</span></span><br><span class="line">    qsort(B, N, <span class="keyword">sizeof</span>(ElementType), cmp);</span><br><span class="line">    <span class="type">int</span> mid = (N + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> B[mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这段代码实现了一个为数组排序并求中位数的功能，奇怪的是直接对A[]排序会wa，将A[]赋值给B[]就AC了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树型dp】旅游规划</title>
      <link href="/2025/10/13/%E3%80%90%E6%A0%91%E5%9E%8BDP%E3%80%91%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/"/>
      <url>/2025/10/13/%E3%80%90%E6%A0%91%E5%9E%8BDP%E3%80%91%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>W市的交通规划出现了重大问题，市政府下定决心在全市各大交通路口安排疏导员来疏导密集的车流。但由于人员不足，W市市长决定只在最需要安排人员的路口安排人员。<br>具体来说，W市的交通网络十分简单，由n个交叉路口和n−1条街道构成，交叉路口路口编号依次为0,1,⋯,n−1。任意一条街道连接两个交叉路口，且任意两个交叉路口间都存在一条路径互相连接。<br>经过长期调查，结果显示，如果一个交叉路口位于W市交通网最长路径上，那么这个路口必定拥挤不堪。所谓最长路径，定义为某条路径p&#x3D;(v1,v2,v3,vk)，路径经过的路口各不相同，且城市中不存在长度大于k的路径，因此最长路径可能不唯一。因此Ｗ市市长想知道哪些路口位于城市交通网的最长路径上。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行一个整数n；<br>之后n−1行每行两个整数u,v，表示u和v的路口间存在着一条街道。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出包括若干行，每行包括一个整数——某个位于最长路径上的路口编号。为了确保解唯一，请将所有最长路径上的路口编号按编号顺序由小到大依次输出。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">0 4</span><br><span class="line">0 6</span><br><span class="line">0 7</span><br><span class="line">1 3</span><br><span class="line">2 5</span><br><span class="line">4 8</span><br><span class="line">6 9</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>对于全部数据，1≤n≤2×10^5^。</p><p>​之前有一道题也是求树上最长路径的，不过只用求最长路径的长度所以只用跑一次dfs就行了。现在还要位于最长路径上的点并且最长路径可能还不止一条，因此要跑第二次dfs了。第一次dfs跑的是求该节点的子树中最长路和次长路，第二次dfs跑的时候求的是该节点向父节点方向的最长路，转移方程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = d1[v] + <span class="number">1</span>;<span class="comment">//当前子路长度</span></span><br><span class="line"><span class="keyword">if</span> (len &gt; d1[u])&#123;<span class="comment">//比最长路长</span></span><br><span class="line">  d2[u] = d1[u];</span><br><span class="line">  d1[u] = len;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (len &gt; d2[u])&#123;<span class="comment">//比次长路长</span></span><br><span class="line"> d2[u] = len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (d1[u] == d1[v] + <span class="number">1</span>)&#123;<span class="comment">//当前子路是父节点的最长路</span></span><br><span class="line">  up[v] = <span class="built_in">max</span>(up[u], d2[u]) + <span class="number">1</span>;<span class="comment">//取父节点的次长路作为子节点的父路</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  up[v] = <span class="built_in">max</span>(up[u], d1[u]) + <span class="number">1</span>;<span class="comment">//否则取父节点的最长路作为子节点的父路</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; </span><br><span class="line">vector &lt;<span class="type">int</span>&gt; adj[maxn];</span><br><span class="line"><span class="type">int</span> d1[maxn], d2[maxn], up[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  d1[u] = <span class="number">0</span>;</span><br><span class="line">  d2[u] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">    <span class="type">int</span> len = d1[v] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; d1[u])&#123;</span><br><span class="line">      d2[u] = d1[u];</span><br><span class="line">      d1[u] = len;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (len &gt; d2[u])&#123;</span><br><span class="line">      d2[u] = len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (d1[u] == d1[v] + <span class="number">1</span>)&#123;</span><br><span class="line">      up[v] = <span class="built_in">max</span>(up[u], d2[u]) + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      up[v] = <span class="built_in">max</span>(up[u], d1[u]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs2</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs1</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">dfs2</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> max_road = <span class="number">0</span>;</span><br><span class="line">  vector &lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="type">int</span> temp = d1[i] + <span class="built_in">max</span>(d2[i], up[i]);</span><br><span class="line">    <span class="keyword">if</span> (temp &gt; max_road)&#123;</span><br><span class="line">      max_road = temp;</span><br><span class="line">      ans.<span class="built_in">clear</span>();</span><br><span class="line">      ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp == max_road)&#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x : ans)&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树型dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【分层图】Magical Girl Haze</title>
      <link href="/2025/10/12/%E5%88%86%E5%B1%82%E5%9B%BE/"/>
      <url>/2025/10/12/%E5%88%86%E5%B1%82%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><strong>题目描述</strong><br>某个国家有 N 座城市，以及 M 条从 u 到 v 的有向道路（1 ≤ u, v ≤ N）。每条道路都有一个距离 ci。<br>Haze 是一位魔法少女，住在城市 1，她可以选择不超过 K 条道路，将它们的距离变为 0。现在她想去城市 N，请你帮她计算从城市 1 到城市 N 的最小距离。</p><p><strong>输入</strong><br>第一行有一个整数 T（1 ≤ T ≤ 5），表示测试用例的数量。<br>对于每个测试用例：</p><ul><li>第一行有三个整数 N, M, K。</li><li>接下来的 M 行，每行有三个整数，描述一条道路：Ui, Vi, Ci。<br>u 和 v 之间可能存在多条道路。</li></ul><p>数据保证：</p><ul><li>N ≤ 100000</li><li>M ≤ 200000</li><li>K ≤ 10</li><li>0 ≤ c[i] ≤ 1e9</li><li>城市 1 和城市 N 之间至少存在一条路径。</li></ul><p><strong>输出</strong><br>对于每个测试用例，输出最小距离。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 6 1</span><br><span class="line">1 2 2</span><br><span class="line">1 3 4</span><br><span class="line">2 4 3</span><br><span class="line">3 4 1</span><br><span class="line">3 5 6</span><br><span class="line">4 5 2</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>​分层图的模板题，无需多言，上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dian</span>&#123;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  ll c;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> dian &amp;a, <span class="type">const</span> dian &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.c &gt; b.c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector &lt;dian&gt; adj[maxn];</span><br><span class="line">priority_queue &lt;dian, vector&lt;dian&gt;, cmp&gt; qe;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    adj[i].<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    ll c;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    adj[a].<span class="built_in">push_back</span>(&#123;b, c, <span class="number">0</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  qe.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">  vector &lt;vector&lt;ll&gt;&gt; <span class="built_in">dis</span>(n + <span class="number">1</span>, vector &lt;ll&gt; (k + <span class="number">1</span>, <span class="number">1e18</span>));</span><br><span class="line">  <span class="keyword">while</span>(!qe.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    dian temp = qe.<span class="built_in">top</span>();</span><br><span class="line">    qe.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (temp.c &gt; dis[temp.b][temp.k]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : adj[temp.b])&#123;</span><br><span class="line">      <span class="keyword">if</span> (temp.k == k)&#123;<span class="comment">//已经用了k次魔法，不能再用了</span></span><br><span class="line">        <span class="keyword">if</span> (temp.c + e.c &lt; dis[e.b][temp.k])&#123;</span><br><span class="line">          dis[e.b][temp.k] = temp.c + e.c;</span><br><span class="line">          qe.<span class="built_in">push</span>(&#123;e.b, temp.c + e.c, temp.k&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.k &lt; k)&#123;<span class="comment">//没到k次，就要分用魔法和不用魔法两种情况讨论</span></span><br><span class="line">        <span class="keyword">if</span> (temp.c + e.c &lt; dis[e.b][temp.k])&#123;</span><br><span class="line">          dis[e.b][temp.k] = temp.c + e.c;</span><br><span class="line">          qe.<span class="built_in">push</span>(&#123;e.b, temp.c + e.c, temp.k&#125;);        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.c &lt; dis[e.b][temp.k + <span class="number">1</span>])&#123;</span><br><span class="line">          dis[e.b][temp.k + <span class="number">1</span>] = temp.c;</span><br><span class="line">          qe.<span class="built_in">push</span>(&#123;e.b, temp.c, temp.k + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; dis[n][k] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【二分图】Magic Potion</title>
      <link href="/2025/10/12/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
      <url>/2025/10/12/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p><strong>题目描述</strong><br>在一个岛屿上住着 n 位英雄和 m 只怪物。这些天怪物变得非常凶残，因此英雄们决定消灭岛上的怪物。然而，第 i 位英雄只能杀死属于集合 Mi 中的一只怪物。<br>策略师 Joe 拥有 k 瓶魔法药水，每瓶药水可以增强一位英雄的能力，让他能够多杀死一只怪物。由于药水非常强大，每位英雄最多只能服用一瓶药水。<br>请帮助 Joe 找出，如果他采用最优策略，英雄们最多能杀死多少只怪物。</p><p><strong>输入</strong><br>第一行包含三个整数 n, m, k（1 ≤ n, m, k ≤ 500）—— 分别表示英雄的数量、怪物的数量和药水的瓶数。<br>接下来的 n 行中，每行首先包含一个整数 ti，表示集合 Mi 的大小，随后是 ti 个整数 Mi,j（1 ≤ j ≤ ti），表示第 i 位英雄能够杀死的怪物的索引（1 起始索引）（1 ≤ ti ≤ m，1 ≤ Mi,j ≤ m）。</p><p><strong>输出</strong><br>输出英雄们能够杀死的怪物的最大数量。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 5 2</span><br><span class="line">4 1 2 3 5</span><br><span class="line">2 2 5</span><br><span class="line">2 1 2</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>​一眼看出是二分图匹配，用匈牙利算法跑了半天没跑出正确答案，原因就在于这个魔法药水。后来发现用网络流做更加简单：首先确立源点1，然后是普通杀怪点2，(1, 2)的容量是n，表示n个英雄各自可以杀一只怪；接着建立嗑药杀怪点3，(1, 3)的容量是k，表示还有至多k个英雄能各自再杀一只怪。最终将2、3与各个英雄相连，英雄与各自能杀的怪相连，所有怪与汇点相连，并将这三步中所有边的容量设置为1，建图就大功告成了。这样跑一遍ISAP，答案就出来了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>, head[N];</span><br><span class="line"><span class="type">int</span> n, m, k, maxflow;</span><br><span class="line"><span class="type">int</span> dep[N], gap[N], cur[N];</span><br><span class="line"><span class="type">int</span> s,t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="type">int</span> v, next, val;</span><br><span class="line">&#125;node[<span class="number">10</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  node[++cnt].v = v;</span><br><span class="line">  node[cnt].val = val;</span><br><span class="line">  node[cnt].next = head[u];</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = s; i &lt;= t; i++)&#123;</span><br><span class="line">    dep[i] = <span class="number">-1</span>;</span><br><span class="line">    gap[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dep[t] = <span class="number">0</span>;</span><br><span class="line">  gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  queue &lt;<span class="type">int</span>&gt; qe;</span><br><span class="line">  qe.<span class="built_in">push</span>(t);</span><br><span class="line">  <span class="keyword">while</span>(!qe.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="type">int</span> u = qe.<span class="built_in">front</span>();</span><br><span class="line">    qe.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = node[i].next)&#123;</span><br><span class="line">      <span class="type">int</span> v = node[i].v;</span><br><span class="line">      <span class="keyword">if</span> (dep[v] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">      qe.<span class="built_in">push</span>(v);</span><br><span class="line">      dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">      gap[dep[v]]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> flow)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (u == t)&#123;</span><br><span class="line">    maxflow += flow;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> used = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> &amp;i = cur[u]; i; i = node[i].next)&#123;</span><br><span class="line">    <span class="type">int</span> v = node[i].v;</span><br><span class="line">    <span class="keyword">if</span> (node[i].val &amp;&amp; dep[v] + <span class="number">1</span> == dep[u])&#123;</span><br><span class="line">      <span class="type">int</span> mi = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(flow - used, node[i].val));</span><br><span class="line">      <span class="keyword">if</span> (mi)&#123;</span><br><span class="line">        node[i].val -= mi;</span><br><span class="line">        node[i ^ <span class="number">1</span>].val += mi;</span><br><span class="line">        used += mi;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (used == flow) <span class="keyword">return</span> used;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  gap[dep[u]]--;</span><br><span class="line">  <span class="keyword">if</span> (gap[dep[u]] == <span class="number">0</span>) dep[s] = t + <span class="number">1</span>;</span><br><span class="line">  dep[u]++;</span><br><span class="line">  gap[dep[u]]++;</span><br><span class="line">  <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ISAP</span><span class="params">()</span></span>&#123;</span><br><span class="line">  maxflow = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">bfs</span>();</span><br><span class="line">  <span class="keyword">while</span>(dep[s] &lt; t + <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s; i &lt;= t + <span class="number">1</span>; i++) cur[i] = head[i];</span><br><span class="line">    <span class="built_in">dfs</span>(s, inf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">  <span class="built_in">addedge</span>(<span class="number">1</span>, <span class="number">2</span>, n);</span><br><span class="line">  <span class="built_in">addedge</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">addedge</span>(<span class="number">1</span>, <span class="number">3</span>, k);</span><br><span class="line">  <span class="built_in">addedge</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  s = <span class="number">1</span>, t = <span class="number">4</span> + n + m;</span><br><span class="line">  <span class="type">int</span> hero_start = <span class="number">4</span>, hero_end = <span class="number">3</span> + n, mon_end = <span class="number">3</span> + m + n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = hero_start; i &lt;= hero_end; i++)&#123;</span><br><span class="line">    <span class="built_in">addedge</span>(<span class="number">2</span>, i, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">addedge</span>(i, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">addedge</span>(<span class="number">3</span>, i, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">addedge</span>(i, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    <span class="keyword">while</span>(num--)&#123;</span><br><span class="line">      <span class="type">int</span> x;</span><br><span class="line">      cin &gt;&gt; x;</span><br><span class="line">      <span class="built_in">addedge</span>(i, hero_end + x, <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">addedge</span>(hero_end + x, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = hero_end + <span class="number">1</span>; i &lt;= mon_end; i++)&#123;</span><br><span class="line">    <span class="built_in">addedge</span>(i, t, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">addedge</span>(t, i, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">ISAP</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 二分图 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树型dp】数字转换</title>
      <link href="/2025/10/12/study-dp-i/"/>
      <url>/2025/10/12/study-dp-i/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>如果一个数x的约数和y（不包括他本身）比他本身小，那么x可以变成y，y也可以变成x。例如4可以变为3，1可以变为7。限定所有数字变换在不超过n的正整数范围内进行，求不断进行数字变换且不出现重复数字的最多变换步数。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>输入一个正整数n。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出不断进行数字变换且不出现重复数字的最多变换步数。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>一种方案为 4→3→1→7<br>对于100%的数据，1≤n≤50000。</p><p>​这一题初看怎么也想不到会是dp，不过在看到n的数字给的比较小后就能想到建图。建图后可以发现得到了一个森林，一开始想跑两遍dfs找最长路径，但后来看了题解发现用树型dp可以只用跑一次dfs。</p><p>​让我们令du[]表示从该节点出发的最长路，dv[]表示次长路，那么转移方程是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">  <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="built_in">dfs</span>(v, u);</span><br><span class="line">  <span class="keyword">if</span> (du[v] &gt; du[u] - <span class="number">1</span>)&#123;<span class="comment">//比最长路要大</span></span><br><span class="line">    dv[u] = du[u] - <span class="number">1</span>;<span class="comment">//原最长路变次长路</span></span><br><span class="line">    du[u] = du[v] + <span class="number">1</span>;<span class="comment">//新的最长路为du[v]加上(u, v)这一条边</span></span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (du[v] &gt; dv[u])&#123;<span class="comment">//比次长路要大</span></span><br><span class="line">    dv[u] = du[v];<span class="comment">//更新次长路</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​下面是完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; adj[<span class="number">50010</span>];</span><br><span class="line"><span class="type">int</span> du[<span class="number">50010</span>], dv[<span class="number">50010</span>], ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">50010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; x++)&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> j = x / i;</span><br><span class="line">        <span class="keyword">if</span> (i != j) sum += i + j;</span><br><span class="line">        <span class="keyword">else</span> sum += i;  </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= <span class="number">1</span> &amp;&amp; sum &lt;= n &amp;&amp; sum &lt; x)&#123;</span><br><span class="line">      adj[x].<span class="built_in">push_back</span>(sum);</span><br><span class="line">      adj[sum].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  vis[u] = <span class="number">1</span>;</span><br><span class="line">  du[u] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    <span class="keyword">if</span> (du[v] &gt; du[u] - <span class="number">1</span>)&#123;</span><br><span class="line">      dv[u] = du[u] - <span class="number">1</span>;</span><br><span class="line">      du[u] = du[v] + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (du[v] &gt; dv[u])&#123;</span><br><span class="line">      dv[u] = du[v];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = <span class="built_in">max</span>(ans, du[u] + dv[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios:: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="built_in">pre</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) <span class="built_in">dfs</span>(i, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans - <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树型dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【区间dp】凸多边形的划分</title>
      <link href="/2025/10/11/study-dp-c/"/>
      <url>/2025/10/11/study-dp-c/</url>
      
        <content type="html"><![CDATA[<p><strong>题目描述</strong><br>给定一个具有N个顶点的凸多边形，将顶点从1至N标号，每个顶点的权值都是一个正整数。将这个凸多边形划分成N−2个互不相交的三角形，试求这些三角形顶点的权值乘积和至少为多少。<br><strong>输入</strong><br>输入第一行为顶点数N（N≤50）<br>第二行依次为顶点1至顶点N的权值。<br><strong>输出</strong><br>输出仅一行，为这些三角形顶点的权值乘积和的最小值。<br><strong>样例输入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">121 122 123 245 231</span><br></pre></td></tr></table></figure><p><strong>样例输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12214884</span><br></pre></td></tr></table></figure><p>​这道题目看似几何问题，实际上居然是一道区间dp。大体思路不难：先选取两个顶点i，j连成一条边，然后在区间[i，j]内找到第三点k作为分割点，转移方程为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k][j] + (i128)w[i] * w[k] * w[j]);</span><br></pre></td></tr></table></figure><p>显而易见在初始化时相邻的两个点连成的边应该初始化为0，其余边初始化为inf。</p><p>还有一点要注意，TK给的数据数值特别大，要开int128或者高精度！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span> &lt;&lt; (ostream &amp;os, i128 n)&#123;</span><br><span class="line">  string s;</span><br><span class="line">  <span class="keyword">while</span>(n)&#123;</span><br><span class="line">    s += <span class="string">&#x27;0&#x27;</span> + n % <span class="number">10</span>;</span><br><span class="line">    n /= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> i128 inf = <span class="number">1e30</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll w[<span class="number">110</span>];</span><br><span class="line">i128 dp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios:: <span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; w[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (j - i &lt; <span class="number">2</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> dp[i][j] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">3</span>; len &lt;= n; len++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)&#123;</span><br><span class="line">      <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)&#123;</span><br><span class="line">        dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k][j] + (i128)w[i] * w[k] * w[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
